<!doctype html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ZIM F&E Kostenkalkulation – Seite 1</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ["Inter", "system-ui", "sans-serif"],
            },
            colors: {
              slate: {
                850: "#0f172a",
              },
            },
            boxShadow: {
              subtle: "0 1px 2px rgba(15, 23, 42, 0.08)",
            },
          },
        },
      };
    </script>
    <style>
      :root {
        --ca-green: #5f7f50;
        --ca-green-soft: #e8efe7;
        --ca-green-soft-strong: #d8e5d5;
        --ca-green-border: #bfd0b9;
        --ca-white: #ffffff;
        --ca-bg: #f2f4f5;
        --ca-border: #d9e1dc;
        --ca-text: #1f2937;
      }

      body {
        font-family: "Inter", system-ui, sans-serif;
        font-size: 100.1%;
        background-color: var(--ca-bg);
        color: var(--ca-text);
      }

      .gantt-grid {
        display: grid;
      }

      .ca-topbar {
        background-color: var(--ca-green);
        color: var(--ca-white);
      }

      .ca-card {
        border: 1px solid var(--ca-border);
        background: #ffffff;
      }

      .ca-primary-btn {
        background-color: var(--ca-green) !important;
        color: var(--ca-white) !important;
      }

      .ca-primary-btn:hover {
        filter: brightness(0.96);
      }

      .ca-focus:focus {
        border-color: var(--ca-green) !important;
        box-shadow: 0 0 0 3px rgba(95, 127, 80, 0.22) !important;
      }

      .bg-slate-900 {
        background-color: var(--ca-green) !important;
      }

      .hover\:bg-slate-800:hover {
        background-color: var(--ca-green) !important;
        filter: brightness(0.96);
      }

      .focus\:border-slate-500:focus {
        border-color: var(--ca-green) !important;
      }

      .focus\:ring-slate-500:focus {
        --tw-ring-color: rgba(95, 127, 80, 0.35) !important;
      }

      @media print {
        .fullscreen-overlay-close {
          display: none !important;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
        <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel" data-presets="typescript,react">
      const { useMemo, useState, useEffect, useRef, useCallback } = React;

      const MAX_WP = 20;
      const MAX_SUB = 20;
      const MAX_DURATION = 60;
      const MAX_EMPLOYEES = 10;
      const DEFAULT_ACTIVE_COMPANY_COUNT = 2;
      const MAX_HISTORY_STEPS = 10;
      const YEAR_CAP_PM = 10.5;
      const PROJECTS_INDEX_KEY = "ca_projectplanning_projects_index";
      const CURRENT_PROJECT_KEY = "ca_projectplanning_current_project";
      const PROJECT_KEY_PREFIX = "project:";
      const SEED_PROJECT_NAME = "CryoVision";
      const AUTO_SAVE_DEBOUNCE_MS = 300;
      const PROJECT_SCHEMA_VERSION = 1;
      const CRYOVISION_SEED_PATH = "/seeds/cryovision.json";
      const DEFAULT_AUTO_LOCKS = {
        employeeAssignment: false,
        workPackageDates: false,
        personMonths: true,
      };
      const formatDateTimeDe = (value) => {
        if (!value) return "–";
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return "–";
        return new Intl.DateTimeFormat("de-DE", {
          day: "2-digit",
          month: "2-digit",
          year: "numeric",
          hour: "2-digit",
          minute: "2-digit",
        }).format(date);
      };

      const monthNames = [
        "Jan",
        "Feb",
        "Mär",
        "Apr",
        "Mai",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Okt",
        "Nov",
        "Dez",
      ];

      const DATA_ARBEITSPAKETE = [
        {
          nr: "1",
          bezeichnung:
            "Grundlegende Definition der Anforderungen an den Gärautomaten und das Arbeitsfluid inklusive der Auslegung geeigneter Kristallisationskeime.",
          pm_ungermann: "",
        },
        {
          nr: "1.1",
          bezeichnung:
            "Analyse des zeitabhängigen thermischen Lastprofils des Gärautomaten für die Betriebsmodi Heizen, Kühlen und Schnell- /Schockfrosten sowie Erstellung eines Lasten- und Pflichtenheftes auf Basis der resultierenden Kälte- und Wärmeanforderungen.",
          pm_ungermann: "0,5",
        },
        {
          nr: "1.2",
          bezeichnung:
            "Grobe Dimensionierung der drei Speicherbehälter (zwei Eisbreispeicher und ein Warmsolespeicher) für die Temperaturniveaus −10 °C, −25 °C und 30 °C einschließlich der erforderlichen Wärmedämmung. Ableitung der benötigten Kälteleistung - aus dem zeitabhängigen Lastprofil unter Berücksichtigung der geometrischen Randbedingungen des Kühlraums (ca. 2 × 2 m) für die Versorgung von bis zu zwei Stikkenwagen mit typischen Endprodukten.",
          pm_ungermann: "",
        },
        {
          nr: "1.3",
          bezeichnung:
            "Auslegung des Arbeitsfluids durch Analyse geeigneter Fluidkombinationen (z. B. Wasser/Ethanol) hinsichtlich ihrer Phasendiagramme für den Temperaturbereich von −25 bis +30 °C sowie Bewertung rheologischer, thermophysikalischer und sicherheitsrelevanter Eigenschaften, einschließlich Lebensmittelverträglichkeit, Viskosität, Wärmeübertragungsvermögen und Entflammbarkeit.",
          pm_ungermann: "",
        },
        {
          nr: "1.4",
          bezeichnung:
            "Auslegung geeigneter Partikel als gezielte Kristallisationskeime im Arbeitsfluid unter Berücksichtigung ihrer Dichte, Oberflächenchemie zur Förderung heterogener Nukleation, chemischen Beständigkeit, Lebensmittelverträglichkeit sowie ihres Einflusses auf das viskose Strömungsverhalten.",
          pm_ungermann: "",
        },
        {
          nr: "2",
          bezeichnung:
            "Stationäre und dynamische Simulation der einzelnen Kältekreisläufe sowie des Gesamtsystems in Engineering Equation Solver oder Python einschließlich der Optimierung von Anlagen- und Betriebsparametern.",
          pm_ungermann: "",
        },
        {
          nr: "2.1",
          bezeichnung:
            "Festlegung der Betriebsfälle und Modellgrenzen in Engineering Equation Solver (EES) oder Python durch eindeutige Definition der drei Teilsysteme (Primärkältekreis, Unterkühlungs-/Kristallisationskreis, Speicher-/Verbraucherkreis) und deren Darstellung in einem Blockdiagramm sowie einer vollständigen Variablenliste.",
          pm_ungermann: "",
        },
        {
          nr: "2.2",
          bezeichnung:
            "Erstellung einer Stoffdatenbasis für Kältemittel, Sole und Eisbrei unter Nutzung von EES-Property-Funktionen oder validierten Literaturdaten sowie Definition eines Enthalpiemodells für Eisbrei mit expliziter Berücksichtigung der latenten Schmelzenthalpie.",
          pm_ungermann: "",
        },
        {
          nr: "2.3",
          bezeichnung:
            "Stationäre Modellierung des Primärkältekreises durch Formulierung der thermodynamischen Gleichungen für Verdichter, Verflüssiger, Expansionsorgan und Verdampfer sowie Berechnung der resultierenden Leistungs- und Exergiegrößen.",
          pm_ungermann: "",
        },
        {
          nr: "2.4",
          bezeichnung:
            "Stationäre Modellierung des Unterkühlungs- und Kristallisationskreises durch Abbildung der beiden Varianten (Kristallisationsverdampfer oder Verdampfer mit separatem Kristallisator), Entwicklung eines Kristallisationsmodells zur Berechnung von Unterkühlungsenthalpie, Eismassenanteil und Fluidtemperatur sowie thermische Kopplung an den Primärkältekreis.",
          pm_ungermann: "",
        },
        {
          nr: "2.5",
          bezeichnung:
            "Dynamische Simulation der Wärme- und Kältespeicher durch Formulierung einer zeitdiskreten Energiebilanz unter Berücksichtigung von Lade- und Entladeleistungen sowie Wärmeverlusten und Berechnung der zeitlichen Entwicklung von Temperatur und Eiskonzentration.",
          pm_ungermann: "",
        },
        {
          nr: "2.6",
          bezeichnung:
            "Stationäre Modellierung des Verbraucherkreislaufs durch Abbildung der Wärmeübertrager mittels UA-Ansätzen und Berechnung der momentanen Kälteleistung in Abhängigkeit der Zu- und Rücklauftemperaturen des Eisbreis.",
          pm_ungermann: "",
        },
        {
          nr: "2.7",
          bezeichnung:
            "Zusammenführung aller zuvor modellierten Teilsysteme zu einer zeitabhängigen Gesamtsimulation auf Basis eines numerischen Zeitschrittverfahrens; für jeden Zeitschritt Berechnung der thermischen Leistungsanforderung, des Speicherbetriebszustands, der erforderlichen Verdampfungs- und Kälteleistung, der Betriebsparameter von Supercooler, Kristallisationseinheit und Pumpensystem sowie der Einhaltung aller zulässigen Betriebsgrenzen.",
          pm_ungermann: "",
        },
        {
          nr: "2.8",
          bezeichnung:
            "Nutzung des Gesamtmodells zur Durchführung parametrischer Studien zur Anlagenoptimierung durch systematische Variation zentraler Auslegungsparameter (Speichergröße, maximal zulässige Eiskonzentration, Verdichterleistung, Wärmeübertrager-UA des Supercoolers, Unterkühlungsgrad) und Bewertung der resultierenden Energiebedarfe, COP-Werte, Temperatur- und Druckgrenzen sowie der Betriebsstabilität.",
          pm_ungermann: "",
        },
        {
          nr: "3",
          bezeichnung:
            "Thermodynamische und strömungsmechanische Untersuchung der Nukleation und Eisbildung im Arbeitsfluid.",
          pm_ungermann: "",
        },
        {
          nr: "3.1",
          bezeichnung:
            "Erstellung eines thermodynamisch-energetischen Basismodells für die Nukleation und Eisbildung durch Definition von Fluidtemperatur, Gefrierpunkt, Unterkühlungsgrad und Mischenthalpie aus Flüssig- und Eisphase sowie Berücksichtigung spezifischer Wärmekapazitäten und latenter Schmelzenthalpie.",
          pm_ungermann: "",
        },
        {
          nr: "3.2",
          bezeichnung:
            "Erweiterung des Basismodells um stoffliche, oberflächenbezogene und geometrische Einflussgrößen des realen Arbeitsfluids, einschließlich thermophysikalischer Stoffdaten, Oberflächeneigenschaften des Kristallisationsverdampfers bzw. Kristallisators und relevanter Geometrieparameter, sowie Entwicklung separater Modelle für heterogene Volumennukleation und Wandnukleation.",
          pm_ungermann: "",
        },
        {
          nr: "3.3",
          bezeichnung:
            "Kalibrierung und Validierung des Nukleationsmodells durch Abgleich von experimentell bestimmten Unterkühlungsgraden, Eismassenanteilen und Temperaturverläufen mit den Modellvorhersagen und anschließende Anpassung kritischer Modellparameter bis zur Konsistenz zwischen Experiment und Simulation.",
          pm_ungermann: "",
        },
        {
          nr: "3.4",
          bezeichnung:
            "Durchführung einer systematischen Parameterstudie, in der Geometrie- und Oberflächenparameter (Rohrdurchmesser, Krümmungsradien, Einbauten/Drallkörper, Rauigkeit, effektiver Kontaktwinkel, Beschichtungsvarianten) variiert werden, um die optimale Kombination zur Minimierung von Wandnukleation und Maximierung der Volumennukleation zu bestimmen.",
          pm_ungermann: "",
        },
        {
          nr: "3.5",
          bezeichnung:
            "Durchführung von CFD-Simulationen zur Optimierung der Verdampfergeometrie mit dem Ziel, wandnahe Strömungsgeschwindigkeiten und Wandschubspannungen zu maximieren, um Wandvereisung zu unterdrücken und die Ablösung entstehender Eiskristalle zu gewährleisten.",
          pm_ungermann: "",
        },
        {
          nr: "4",
          bezeichnung:
            "Experimentelle Charakterisierung, Validierung und prototypische Umsetzung des Kristallisationsverdampfers im Temperaturbereich von −10 bis −25 °C.",
          pm_ungermann: "",
        },
        {
          nr: "4.1",
          bezeichnung:
            "Charakterisierung des Arbeitsfluids (z. B. Wasser–Ethanol) durch Bestimmung von Viskosität (Kapillarrohr-Viskometer), Dichte, Wärmekapazität, Wärmeleitfähigkeit, Gefrierpunkt und Wärmeübergangskoeffizienten bei variierenden Temperaturen und Eismassenanteilen.",
          pm_ungermann: "",
        },
        {
          nr: "4.2",
          bezeichnung:
            "Experimentelle Untersuchung zuvor simulierter Oberflächenmaterialien hinsichtlich Unterkühlungsstabilität, Nukleationsneigung, Eisadhäsion und Abriebbeständigkeit; Herstellung definierter Platten oder Rohrsegmente mit simulierten Beschichtungen (z. B. PTFE-artige Schichten oder nickelhaltige Metalloberflächen).",
          pm_ungermann: "2",
        },
        {
          nr: "4.3",
          bezeichnung:
            "Bestimmung des Nukleationszeitpunkts durch Eintauchen der Oberflächen in unterkühlte Fluide und Detektion mittels optischer bzw. akustischer Sensorik sowie Analyse der hydrodynamischen Ablösung und Ermittlung der Eisadhäsionsspannung.",
          pm_ungermann: "1,5",
        },
        {
          nr: "4.4",
          bezeichnung:
            "Systematischer Vergleich der Oberflächenvarianten bezüglich Unterkühlungsstabilität, Nukleationsneigung, Adhäsionskraft und Versuchswiederholbarkeit sowie Ableitung von Designregeln zur Minimierung von Wandausfrierung.",
          pm_ungermann: "2,5",
        },
        {
          nr: "4.5",
          bezeichnung:
            "Aufbau des zuvor simulierten Rohrleitungssystems des Kristallisationsverdampfers für experimentelle Untersuchungen zur Abspülbarkeit von Eiskristallen unter realitätsnahen Strömungsbedingungen.",
          pm_ungermann: "2,5",
        },
        {
          nr: "4.6",
          bezeichnung:
            "Variation der Rohrgeometrie in vier definierten Varianten (Coiled Tubes, wellige Rohre, Rohre mit Helixstrukturen, Rohre mit flachen Noppen) zur Erzeugung lokaler Geschwindigkeitsmaxima sowie gezielter Sekundärströmungen und Wirbelstrukturen an der Wand.",
          pm_ungermann: "3",
        },
        {
          nr: "4.7",
          bezeichnung:
            "Aufbau eines transparenten Teststands (Plexiglasrohrsystem) mit Pumpeneinheit, Kältekreislauf, Beleuchtung und Kamerasystem zur Visualisierung von Kristallisation, Wandbedeckung und Ablöseprozessen.",
          pm_ungermann: "3",
        },
        {
          nr: "4.8",
          bezeichnung:
            "Durchführung systematischer Versuchsreihen unter Variation von Geometrie, Strömungsgeschwindigkeit, Temperatur und Keimpartikelkonzentration zur Quantifizierung und Optimierung der hydrodynamischen Kristallabspülung.",
          pm_ungermann: "2,5",
        },
        {
          nr: "4.9",
          bezeichnung:
            "Optische Auswertung der zeitabhängigen Wandbedeckung durch regelmäßige Bildaufnahme, Bestimmung der Zeit bis zur Ausbildung einer geschlossenen Eisbrücke (Blockade) und Auswahl eines optimalen Rohrdesigns.",
          pm_ungermann: "1,5",
        },
        {
          nr: "4.10",
          bezeichnung:
            "Fertigung eines Prototyps des Kristallisationsverdampfers mit der identifizierten optimalen Rohrgeometrie und Oberflächenbeschichtung sowie Wiederholung der Blockadetests zur quantitativen Bewertung der Betriebsstabilität.",
          pm_ungermann: "3",
        },
        {
          nr: "5",
          bezeichnung:
            "Experimentelle Entwicklung und Validierung eines Supercoolers und eines Kristallisators für den Temperaturbereich von −2 bis −5 °C.",
          pm_ungermann: "",
        },
        {
          nr: "5.1",
          bezeichnung:
            "Erneute experimentelle Untersuchung und Optimierung der Oberflächenbeschichtungen unter angepasster Fluidzusammensetzung durch Herstellung definierter Probekörper, Eintauchen in unterkühlte Fluide sowie Bestimmung von Nukleationszeitpunkt und Eisadhäsionsspannung, um die leistungsfähigsten Oberflächenvarianten zu identifizieren.",
          pm_ungermann: "",
        },
        {
          nr: "5.2",
          bezeichnung:
            "Aufbau eines Verdampfers (Supercoolers) mit nicht optimierter Rohrgeometrie, ausgestattet mit den zuvor identifizierten Beschichtungsvarianten, und experimentelle Bestimmung des maximal stabilen Unterkühlungsgrades bis zur Erstkristallisation zur Auswahl eines finalen, unterkühlungsstabilen Beschichtungssystems.",
          pm_ungermann: "",
        },
        {
          nr: "5.3",
          bezeichnung:
            "Entwicklung und Validierung eines Nukleators mit homogenisierter Strömungsführung und beschichteten Kontaktoberflächen sowie Implementierung aktiver Triggermechanismen (Ultraschall, Peltier-Element). Durchführung systematischer Vergleichsversuche zur Bestimmung der Kristallisationsauslösezeit, der Reproduzierbarkeit und der Robustheit gegenüber thermischen und hydraulischen Störgrößen zur Auswahl des optimalen Auslöseverfahrens.",
          pm_ungermann: "",
        },
        {
          nr: "5.4",
          bezeichnung:
            "Auslegung und experimentelle Prüfung eines thermischen Schutzsystems zur Verhinderung des Eindringens der Kristallisationsfront in den Supercooler durch Integration beheizbarer Rohrabschnitte, Nutzung des temperierten Kältemittels aus dem Verflüssiger sowie Entwicklung eines dazugehörigen Bypass- und Regelkonzeptes zur definierten thermischen Stabilisierung der Grenzbereiche.",
          pm_ungermann: "",
        },
        {
          nr: "5.5",
          bezeichnung:
            "Entwicklung eines präzisen Temperaturregelkonzepts für den Supercooler durch Aufbau einer kaskadierten Regelstruktur, bei der der innere Regler das elektronische Expansionsventil (EEV) steuert und der äußere Regler die Austrittstemperatur des Arbeitsfluids stabil im zulässigen Unterkühlungsbereich hält.",
          pm_ungermann: "2,5",
        },
        {
          nr: "5.6",
          bezeichnung:
            "Experimentelle Untersuchung des Gesamtsystems aus Supercooler und Kristallisator durch Variation von Unterkühlungsgrad, Massenstrom und Triggermechanismus, Messung der stabil erreichbaren Unterkühlung im Supercooler, Erfassung der zeitlichen und mengenmäßigen Kristallbildung im Kristallisator sowie Bewertung der Betriebsstabilität hinsichtlich Temperaturführung, Eismassenanteil und Wiederholbarkeit.",
          pm_ungermann: "",
        },
        {
          nr: "6",
          bezeichnung:
            "Entwicklung eines Systems zur Steuerung der Eisbreikonzentration sowie Auslegung von Peripheriekomponenten.",
          pm_ungermann: "",
        },
        {
          nr: "6.1",
          bezeichnung:
            "Entwicklung eines variablen Rührwerks im Eisbreispeicher, bei dem Höhe und Betriebsparameter gezielt angepasst werden, um eine stabile Eiskonzentration von 20–25 % an den Verbrauchern bereitzustellen.",
          pm_ungermann: "2",
        },
        {
          nr: "6.2",
          bezeichnung:
            "Entwicklung einer Methode zur Bestimmung des Eisanteils über Temperaturmessung oder dichtebasierte Sensorik (z. B. Coriolis), unter Berücksichtigung des Dichteunterschieds zwischen Flüssigphase und Eis.",
          pm_ungermann: "2",
        },
        {
          nr: "6.3",
          bezeichnung:
            "Erarbeitung einer Steuer- und Regelstrategie für ein höhenverstellbares, drehzahlgeregeltes Rührwerk, einschließlich Definition geeigneter Betriebsmodi (z. B. Intervallbetrieb, partielles Rühren im unteren Tankbereich).",
          pm_ungermann: "1,5",
        },
        {
          nr: "6.4",
          bezeichnung:
            "Durchführung systematischer Versuchsreihen zur Untersuchung des Einflusses von Rührhöhe, Drehzahl und Einschaltdauer auf erreichbare Eiskonzentration und elektrischen Energiebedarf sowie Ableitung einer optimalen Regel- und Steuerstrategie.",
          pm_ungermann: "1,5",
        },
        {
          nr: "6.5",
          bezeichnung:
            "Identifikation geeigneter Pumpentypen für hochviskose, kalte und partikelhaltige Fluide sowie Durchführung von Dauerversuchen zur Bewertung von Förderleistung, Druckverlust, Vereisungsanfälligkeit und Verschleißverhalten bei −25 °C und variierenden Eiskonzentrationen und Keimpartikelanteilen.",
          pm_ungermann: "1",
        },
        {
          nr: "6.6",
          bezeichnung:
            "Entwicklung eines Wärmeübertragers auf der Verbraucherseite, der eine störungsfreie Durchströmung von Eispartikeln ermöglicht, durch Anpassung von Kanal- und Rohrdurchmessern, Minimierung enger Umlenkungen sowie Auswahl geeigneter, abrasionsbeständiger Materialien und Oberflächen.",
          pm_ungermann: "2",
        },
        {
          nr: "6.7",
          bezeichnung:
            "Entwicklung eines Systems zur aktiven Anpassung der Fluidzusammensetzung (z. B. Wasser–Ethanol), um über die konzentrationsabhängige Gefrierpunktkurve unterschiedliche Eisbreitemperaturen gezielt einstellen zu können.",
          pm_ungermann: "2,5",
        },
        {
          nr: "6.8",
          bezeichnung:
            "Aufbau der Hardware zur automatisierten Konzentrationsanpassung, bestehend aus Osmoseeinheit zur Wasserabtrennung, zwei Pufferbehältern (konzentrierte Lösung und Reinstwasser), Dosier- und Mischpumpe sowie Inline-Sensorik (Dichte bzw. Refraktometrie und Temperatur) zur kontinuierlichen Konzentrationsbestimmung.",
          pm_ungermann: "3",
        },
        {
          nr: "6.9",
          bezeichnung:
            "Entwicklung einer Steuerlogik zur Einstellung des Soll-Gefrierpunkts bzw. der Soll-Konzentration (Modus −10 °C oder −25 °C) mittels Rückführung der Inline-Sensorik und Erprobung des Gesamtsystems im Betrieb.",
          pm_ungermann: "1,5",
        },
        {
          nr: "7",
          bezeichnung:
            "Prototypischer Aufbau des Gärautomaten und Entwicklung einer Smart-Grid-gestützten Fahrplanlogik.",
          pm_ungermann: "",
        },
        {
          nr: "7.1",
          bezeichnung:
            "Aufbau der Primärkältemaschine bestehend aus Verdichter, Verflüssiger, Expansionsventil und der thermischen Kopplung des Verdampfers an den Sekundärkreislauf sowie Integration des Verdampfers in den Prozessfluss des Arbeitsfluids.",
          pm_ungermann: "2",
        },
        {
          nr: "7.2",
          bezeichnung:
            "Einbindung des Verdampfers als Kristallisationsmodul im Sekundärkreislauf, sodass Unterkühlung und Kristallisation im selben Bauteil stattfinden, sowie Montage der Eisbreispeicher mit höhenverstellbarem Rührwerk und Sensorik zur Temperatur- und Konzentrationsmessung.",
          pm_ungermann: "1,5",
        },
        {
          nr: "7.3",
          bezeichnung:
            "Installation des Verbraucherkreises mit Sole-Luft-Wärmeübertragern für den Gärautomaten, wobei Kanalgeometrien und Materialauswahl auf die strömungsmechanischen Anforderungen von Eisbrei und Keimpartikeln ausgelegt werden.",
          pm_ungermann: "1,5",
        },
        {
          nr: "7.4",
          bezeichnung:
            "Aufbau des Rohrnetzes und der Pumpentechnik unter Berücksichtigung der hohen Viskosität, der abrasiven Partikelanteile und der niedrigen Betriebstemperaturen (−25 °C) sowie Integration erforderlicher Absperr-, Umschalt- und Regelventile für den systemweiten Betrieb.",
          pm_ungermann: "1",
        },
        {
          nr: "7.5",
          bezeichnung:
            "Installation der Sensor- und Regelungstechnik durch Positionierung von Temperatur-, Druck- und Konzentrationssensoren an Ein- und Austritt des Verdampfers, in kritischen Rohrabschnitten sowie im Eisbreispeicher zur kontinuierlichen Prozessüberwachung.",
          pm_ungermann: "1",
        },
        {
          nr: "7.6",
          bezeichnung:
            "Entwicklung einer prädiktiven Steuerungslogik zur modellbasierten Ableitung optimaler Lade- und Befüllstrategien für zwei sequentiell zu ladende Eisbreispeicher unter Einbezug externer Prognosesignale (Energiepreise, PV-Ertrag) sowie Formulierung von Entscheidungsregeln zu Füllreihenfolge, Sollfüllständen und teil- bzw. vollbefüllten Betriebsweisen.",
          pm_ungermann: "1,5",
        },
        {
          nr: "7.7",
          bezeichnung:
            "Entwicklung selbstlernender Algorithmen zur automatisierten Analyse historischer Lastprofile der Bäckerei und deren Abgleich mit Erzeugungsprognosen, um zeitoptimal gesteuerte Ladezeitpunkte sowie energieeffiziente Betriebsstrategien für die Speicher abzuleiten.",
          pm_ungermann: "2,5",
        },
        {
          nr: "8",
          bezeichnung:
            "Experimentelle Gesamtvalidierung, Leistungsbewertung und Langzeiterprobung des Systems.",
          pm_ungermann: "",
        },
        {
          nr: "8.1",
          bezeichnung:
            "Inbetriebnahme und Funktionsprüfung durch Erstbefüllung des Systems mit reiner Sole ohne Eisanteil sowie Durchführung von Dichtheits-, Druck- und Durchflusstests und anschließender Kalibrierung aller Messketten für Temperatur, Druck, Volumenstrom und Dichte.",
          pm_ungermann: "0,5",
        },
        {
          nr: "8.2",
          bezeichnung:
            "Parametrierung des Kristallisationsverdampfers durch schrittweise Absenkung der Verdampfungstemperatur zur Identifikation eines stabilen Unterkühlungsfensters ohne Festfrieren und Verifizierung des Selbstreinigungseffekts (Eisablösung) durch Analyse lokaler Druckverluste und Temperaturprofile.",
          pm_ungermann: "1",
        },
        {
          nr: "8.3",
          bezeichnung:
            "Test der Eisbreibereitstellung unter realen Betriebsbedingungen durch Durchführung definierter Gärautomat-Zyklen (Gären, Kühlen, Frosten) und Messung der resultierenden Kälteleistung, Eiskonzentration, Produkt-Temperaturverläufe sowie der Strömungsstabilität im Sekundärkältekreislauf.",
          pm_ungermann: "1",
        },
        {
          nr: "8.4",
          bezeichnung:
            "Energetische und hydraulische Bewertung durch Messung der elektrischen Leistungsaufnahme von Verdichter, Pumpen und Rührwerken in verschiedenen Betriebsmodi sowie quantitativer Erfassung der Druckverluste, Identifikation von Bereichen mit erhöhtem Clogging-Risiko und Bestimmung des COP.",
          pm_ungermann: "1",
        },
        {
          nr: "8.5",
          bezeichnung:
            "Langzeittest über mehrere Wochen zur Untersuchung der Stabilität von Eiskonzentration und Fluidzusammensetzung, der Abrasion und des Verschleißverhaltens von Pumpen und Verdampfer sowie des Auftretens möglicher Clogging-Ereignisse und Ableitung geeigneter Reinigungs- und Wartungsintervalle.",
          pm_ungermann: "1,5",
        },
        {
          nr: "8.6",
          bezeichnung:
            "Validierung des Gesamtsystems durch Vergleich der experimentell ermittelten Eismassenanteile, Temperaturprofile und Druckverluste mit den Simulationsergebnissen, Anpassung wesentlicher Modellparameter wie Wärmeübergangs- und rheologischer Kennwerte und Ableitung finaler Auslegungsrichtlinien für die Serienentwicklung.",
          pm_ungermann: "2,5",
        },
      ];

      const COMPANY1_PRESET = {
        projectStartDate: "2026-06-01",
        durationMonths: 30,
        companyName: "Ungermann GmbH",
        employees: [
          {
            partTimeFactor: 1,
            projectPercent: 75,
            name: "Jörg Ungermann",
            weeklyHours: 40,
            actualHours: 40,
            annualSalary: 84000,
          },
          {
            partTimeFactor: 1,
            projectPercent: 75,
            name: "Kai Ungermann",
            weeklyHours: 40,
            actualHours: 40,
            annualSalary: 62101.12,
          },
          {
            partTimeFactor: 1,
            projectPercent: 100,
            name: "Mohammed Ahmed Turki Al-",
            weeklyHours: 40,
            actualHours: 40,
            annualSalary: 54000,
          },
          {
            partTimeFactor: 1,
            projectPercent: 100,
            name: "Maxim Derr",
            weeklyHours: 40,
            actualHours: 40,
            annualSalary: 51700,
          },
          {
            partTimeFactor: 1,
            projectPercent: 100,
            name: "Thomas Schotte",
            weeklyHours: 40,
            actualHours: 40,
            annualSalary: 46384,
          },
        ],
        workPackageSource: DATA_ARBEITSPAKETE,
      };

      const COMPANY1_ASSIGNMENTS = [
        { number: "1.1", start: "06.2026", end: "12.2026", employee: "1" },
        { number: "4.2", start: "01.2027", end: "07.2027", employee: "1" },
        { number: "4.3", start: "01.2027", end: "07.2027", employee: "1" },
        { number: "4.4", start: "01.2027", end: "07.2027", employee: "1" },
        { number: "4.5", start: "01.2027", end: "07.2027", employee: "2" },
        { number: "4.6", start: "01.2027", end: "07.2027", employee: "2" },
        { number: "4.7", start: "01.2027", end: "07.2027", employee: "3" },
        { number: "4.8", start: "01.2027", end: "07.2027", employee: "4" },
        { number: "4.9", start: "01.2027", end: "07.2027", employee: "4" },
        { number: "4.10", start: "01.2027", end: "07.2027", employee: "4" },
        { number: "5.5", start: "07.2027", end: "12.2027", employee: "3" },
        { number: "6.1", start: "07.2027", end: "02.2028", employee: "3" },
        { number: "6.2", start: "07.2027", end: "02.2028", employee: "3" },
        { number: "6.3", start: "07.2027", end: "02.2028", employee: "4" },
        { number: "6.4", start: "07.2027", end: "02.2028", employee: "4" },
        { number: "6.5", start: "07.2027", end: "02.2028", employee: "4" },
        { number: "6.6", start: "07.2027", end: "02.2028", employee: "5" },
        { number: "6.7", start: "07.2027", end: "02.2028", employee: "5" },
        { number: "6.8", start: "07.2027", end: "02.2028", employee: "5" },
        { number: "6.9", start: "07.2027", end: "02.2028", employee: "5" },
        { number: "7.1", start: "02.2028", end: "08.2028", employee: "5" },
        { number: "7.2", start: "02.2028", end: "08.2028", employee: "5" },
        { number: "7.3", start: "02.2028", end: "08.2028", employee: "5" },
        { number: "7.4", start: "02.2028", end: "08.2028", employee: "4" },
        { number: "7.5", start: "02.2028", end: "08.2028", employee: "4" },
        { number: "7.6", start: "02.2028", end: "08.2028", employee: "4" },
        { number: "7.7", start: "02.2028", end: "08.2028", employee: "4" },
        { number: "8.1", start: "07.2028", end: "11.2028", employee: "4" },
        { number: "8.2", start: "07.2028", end: "11.2028", employee: "3" },
        { number: "8.3", start: "07.2028", end: "11.2028", employee: "3" },
        { number: "8.4", start: "07.2028", end: "11.2028", employee: "3" },
        { number: "8.5", start: "07.2028", end: "11.2028", employee: "2" },
        { number: "8.6", start: "07.2028", end: "11.2028", employee: "2" },
      ];

      const COMPANY1_ASSIGNMENT_MAP = COMPANY1_ASSIGNMENTS.reduce((acc, entry) => {
        acc[entry.number] = entry;
        return acc;
      }, {});

      const clampNumber = (value, min, max) => Math.min(max, Math.max(min, value));
      const parseLocaleNumber = (value) => {
        if (value === "" || value === null || value === undefined) return 0;
        if (typeof value === "number") return value;
        const trimmed = `${value}`.trim().replace(/\s/g, "");
        if (!trimmed) return 0;
        let normalized = trimmed;
        if (trimmed.includes(",")) {
          normalized = trimmed.replace(/\./g, "").replace(/,/g, ".");
        }
        const parsed = Number.parseFloat(normalized);
        return Number.isNaN(parsed) ? 0 : parsed;
      };

      const parseNumber = (value) => {
        if (value === "" || value === null || value === undefined) return 0;
        const parsed = parseLocaleNumber(value);
        return Number.isNaN(parsed) ? 0 : parsed;
      };

      const getEffectiveProjectPercent = (value) => {
        if (value === "" || value === null || value === undefined) return 100;
        return clampNumber(parseNumber(value), 0, 999);
      };

      const COMPANY_COLORS = ["#5b8fd6", "#cf6a5e", "#8ebf6a", "#d0a45e", "#7a5bb8"];
      const withAlpha = (hex, alpha) => {
        const normalized = `${hex}`.replace("#", "");
        if (normalized.length !== 6) return hex;
        const r = Number.parseInt(normalized.slice(0, 2), 16);
        const g = Number.parseInt(normalized.slice(2, 4), 16);
        const b = Number.parseInt(normalized.slice(4, 6), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      };

      const getCompanyColorHex = (companyIndex) =>
        COMPANY_COLORS[companyIndex % COMPANY_COLORS.length] || COMPANY_COLORS[0];

      const getCompanyColorPalette = (companyIndex) => {
        const base = getCompanyColorHex(companyIndex);
        return {
          base,
          strip: base,
          bar: withAlpha(base, 0.85),
          barBorder: base,
          inputFocus: withAlpha(base, 0.25),
        };
      };

      const DEFAULT_COMPANY_NAMES = Array.from({ length: 5 }, (_, index) => `Unternehmen ${index + 1}`);
      const DEFAULT_START_DATE = "2026-07-15";
      const DEFAULT_DURATION_MONTHS = 48;
      const SUB_WORK_PACKAGE_NUMBER_REGEX = /^\d+(\.\d+)+$/;

      const isSubWorkPackageNumber = (value) => SUB_WORK_PACKAGE_NUMBER_REGEX.test(`${value || ""}`.trim());

      const createWp = (index) => ({
        id: `wp-${Date.now()}-${index}`,
        title: "",
        pm: Array(5).fill(""),
        sub: [],
      });

      const createSub = (wpIndex, index) => ({
        id: `sub-${Date.now()}-${wpIndex}-${index}`,
        title: "",
        pm: Array(5).fill(""),
      });

      const createCompanyData = () => ({
        zuschlagsfaktorPercent: 100,
        foerderquotePercent: 45,
        maximalbetrag: 560000,
        autoPlanningLocks: { ...DEFAULT_AUTO_LOCKS },
        ergebnisse: {
          personalkosten: 0,
          gemeinkostenzuschlag: 0,
          projektsumme: 0,
          foerdersumme: 0,
          verschenkterGesamtbetrag: 0,
        },
        tabellenEintraege: {},
      });

      const createEmployee = () => ({
        partTimeFactor: 1,
        projectPercent: 100,
        name: "",
        weeklyHours: 40,
        actualHours: 40,
        annualSalary: 0,
      });

      const parsePresetPmValue = (value) => {
        if (value === "" || value === null || value === undefined) return "";
        const trimmed = `${value}`.trim();
        if (!trimmed) return "";
        const normalized = trimmed.replace(",", ".");
        const parsed = Number.parseFloat(normalized);
        return Number.isNaN(parsed) ? "" : parsed;
      };

      const buildPresetWorkPackages = (data) => {
        const buildPmRow = (value = "") => [value, "", "", "", ""];
        const result = [];
        let currentWp = null;
        data.forEach((entry, index) => {
          const isHeader = !entry.nr.includes(".");
          if (isHeader) {
            currentWp = {
              id: `wp-preset-${Date.now()}-${index}`,
              title: entry.bezeichnung,
              pm: buildPmRow(""),
              sub: [],
            };
            result.push(currentWp);
            return;
          }
          if (!currentWp) return;
          const pmValue = parsePresetPmValue(entry.pm_ungermann);
          currentWp.sub.push({
            id: `sub-preset-${Date.now()}-${index}`,
            title: entry.bezeichnung,
            pm: buildPmRow(pmValue),
          });
        });
        return result;
      };

      const createDefaultWorkPackages = () => {
        const wp = createWp(0);
        wp.sub = [createSub(0, 0)];
        return [wp];
      };

      const createEmployeesByCompany = () =>
        Array.from({ length: 5 }, () => [createEmployee()]);

      const normalizeCompanyData = (data) => {
        const base = Array.from({ length: 5 }, () => createCompanyData());
        if (!Array.isArray(data)) return base;
        return base.map((fallback, index) => {
          const entry = data[index] || {};
          return {
            ...fallback,
            ...entry,
            autoPlanningLocks: {
              ...DEFAULT_AUTO_LOCKS,
              ...(entry.autoPlanningLocks || {}),
            },
            ergebnisse: {
              ...fallback.ergebnisse,
              ...(entry.ergebnisse || {}),
            },
            tabellenEintraege: entry.tabellenEintraege || {},
          };
        });
      };

      const parseDate = (value) => {
        const parsed = new Date(value);
        if (Number.isNaN(parsed.getTime())) {
          const fallback = new Date();
          return new Date(fallback.getFullYear(), fallback.getMonth(), 1);
        }
        return new Date(parsed.getFullYear(), parsed.getMonth(), 1);
      };

      const toIsoDate = (dateValue) => {
        const date = dateValue instanceof Date ? dateValue : parseDate(dateValue);
        return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}-${String(date.getDate()).padStart(2, "0")}`;
      };

      const parseMonthYear = (value) => {
        if (!value) return null;
        const [monthPart, yearPart] = `${value}`.trim().split(".");
        const month = Number.parseInt(monthPart, 10);
        const year = Number.parseInt(yearPart, 10);
        if (!Number.isFinite(month) || !Number.isFinite(year)) return null;
        if (month < 1 || month > 12) return null;
        return { year, month: month - 1 };
      };

      const getMonthSpan = (startValue, endValue) => {
        const start = parseMonthYear(startValue);
        const end = parseMonthYear(endValue);
        if (!start || !end) return null;
        const startIndex = start.year * 12 + start.month;
        const endIndex = end.year * 12 + end.month;
        if (endIndex < startIndex) return null;
        const monthsByYear = {};
        let totalMonths = 0;
        for (let index = startIndex; index <= endIndex; index += 1) {
          const year = Math.floor(index / 12);
          monthsByYear[year] = (monthsByYear[year] || 0) + 1;
          totalMonths += 1;
        }
        return { totalMonths, monthsByYear };
      };

      const roundToTwo = (value) =>
        Math.round((Number.isFinite(value) ? value : 0) * 100) / 100;

      const cloneTableEntries = (entries) =>
        JSON.parse(JSON.stringify(entries || {}));

      const clonePmSnapshot = (snapshot) =>
        snapshot ? JSON.parse(JSON.stringify(snapshot)) : null;

      const createCompanyHistorySnapshot = (tabellenEintraege = {}, pmSnapshot = null) => ({
        tabellenEintraege: cloneTableEntries(tabellenEintraege),
        pmSnapshot: clonePmSnapshot(pmSnapshot),
      });

      const normalizeCompanyHistorySnapshot = (snapshot) => {
        if (!snapshot || typeof snapshot !== "object") {
          return createCompanyHistorySnapshot({});
        }
        if (Object.prototype.hasOwnProperty.call(snapshot, "tabellenEintraege")) {
          return createCompanyHistorySnapshot(snapshot.tabellenEintraege, snapshot.pmSnapshot || null);
        }
        return createCompanyHistorySnapshot(snapshot, null);
      };

      const createHistoryState = (snapshot = {}, pmSnapshot = null) => ({
        history: [createCompanyHistorySnapshot(snapshot, pmSnapshot)],
        historyIndex: 0,
      });

      const createCompanyHistoryByCompany = (data = null) => {
        const normalizedData = normalizeCompanyData(data);
        return normalizedData.map((entry) => createHistoryState(entry.tabellenEintraege));
      };

      const buildDefaultProjectState = () => {
        const companyData = normalizeCompanyData();
        return {
          schemaVersion: PROJECT_SCHEMA_VERSION,
          workPackages: createDefaultWorkPackages(),
          companyCount: DEFAULT_ACTIVE_COMPANY_COUNT,
          companyNames: [...DEFAULT_COMPANY_NAMES],
          startDate: DEFAULT_START_DATE,
          durationMonths: DEFAULT_DURATION_MONTHS,
          employeesByCompany: createEmployeesByCompany(),
          companyData,
          companyHistoryByCompany: createCompanyHistoryByCompany(companyData),
        };
      };

      const buildSeedCryoVisionState = () => {
        const workPackages = buildPresetWorkPackages(COMPANY1_PRESET.workPackageSource);
        const employeesByCompany = createEmployeesByCompany();
        employeesByCompany[0] = COMPANY1_PRESET.employees.map((employee) => ({
          ...createEmployee(),
          ...employee,
        }));
        const companyData = normalizeCompanyData();
        const rows = [];
        workPackages.forEach((wp, wpIndex) => {
          wp.sub.forEach((sub, subIndex) => {
            rows.push({ id: sub.id, number: `${wpIndex + 1}.${subIndex + 1}` });
          });
        });
        companyData[0].tabellenEintraege = rows.reduce((acc, row) => {
          const assignment = COMPANY1_ASSIGNMENT_MAP[row.number];
          if (assignment) {
            acc[row.id] = {
              start: assignment.start,
              ende: assignment.end,
              mitarbeiterNummer: assignment.employee,
            };
          }
          return acc;
        }, {});

        return {
          schemaVersion: PROJECT_SCHEMA_VERSION,
          workPackages,
          companyCount: 5,
          companyNames: DEFAULT_COMPANY_NAMES.map((name, index) =>
            index === 0 ? COMPANY1_PRESET.companyName : name
          ),
          startDate: COMPANY1_PRESET.projectStartDate,
          durationMonths: COMPANY1_PRESET.durationMonths,
          employeesByCompany,
          companyData,
          companyHistoryByCompany: createCompanyHistoryByCompany(companyData),
        };
      };

      const getProjectStorageKey = (projectId) =>
        `${PROJECT_KEY_PREFIX}${encodeURIComponent(projectId)}`;

      const sanitizePmValue = (value) => {
        if (value === "" || value === null || value === undefined) return "";
        const parsed = Number.parseFloat(`${value}`.replace(",", "."));
        if (!Number.isFinite(parsed) || parsed < 0) return "";
        return parsed;
      };

      const sanitizePmRow = (pmRow, { allowValues = true, context = "" } = {}) => {
        const next = Array.from({ length: 5 }, (_, index) => sanitizePmValue(pmRow?.[index]));
        if (!allowValues) {
          next.forEach((value, index) => {
            if (value !== "" && value > 0) {
              console.warn(`PM-Wert für Überschrift entfernt (${context}, Unternehmen ${index + 1}).`);
            }
          });
          return Array(5).fill("");
        }
        return next;
      };

      const sanitizeWorkPackages = (workPackages) => {
        if (!Array.isArray(workPackages) || !workPackages.length) return createDefaultWorkPackages();
        return workPackages.map((wp, wpIndex) => ({
          id: wp?.id || `wp-${Date.now()}-${wpIndex}`,
          title: wp?.title || "",
          pm: sanitizePmRow(wp?.pm, {
            allowValues: false,
            context: `${wpIndex + 1}`,
          }),
          sub: Array.isArray(wp?.sub) && wp.sub.length
            ? wp.sub.map((sub, subIndex) => ({
                id: sub?.id || `sub-${Date.now()}-${wpIndex}-${subIndex}`,
                title: sub?.title || "",
                pm: sanitizePmRow(sub?.pm, {
                  allowValues: true,
                  context: `${wpIndex + 1}.${subIndex + 1}`,
                }),
              }))
            : [createSub(wpIndex, 0)],
        }));
      };

      const migrateProjectState = (oldState) => {
        const defaults = buildDefaultProjectState();
        const parsed = oldState && typeof oldState === "object" ? oldState : {};
        const companyCount =
          typeof parsed.companyCount === "number"
            ? clampNumber(parsed.companyCount, 1, 5)
            : defaults.companyCount;
        const next = {
          schemaVersion: PROJECT_SCHEMA_VERSION,
          workPackages: sanitizeWorkPackages(parsed.workPackages),
          companyNames: Array.isArray(parsed.companyNames) && parsed.companyNames.length
            ? [...defaults.companyNames].map((name, index) => `${parsed.companyNames[index] || name}`)
            : defaults.companyNames,
          companyCount,
          startDate: parsed?.startDate || defaults.startDate,
          durationMonths: clampNumber(parseNumber(parsed?.durationMonths) || defaults.durationMonths, 1, MAX_DURATION),
          employeesByCompany: Array.isArray(parsed?.employeesByCompany)
            ? defaults.employeesByCompany.map((fallback, index) => {
                const list = parsed.employeesByCompany[index];
                return Array.isArray(list)
                  ? list.map((employee) => ({
                      ...createEmployee(),
                      ...employee,
                      partTimeFactor: clampNumber(parseNumber(employee?.partTimeFactor), 0, 1),
                      projectPercent: clampNumber(parseNumber(employee?.projectPercent), 0, 100),
                      weeklyHours: clampNumber(parseNumber(employee?.weeklyHours), 0, 999),
                      actualHours: clampNumber(parseNumber(employee?.actualHours), 0, 999),
                      annualSalary: clampNumber(parseNumber(employee?.annualSalary), 0, 999999999),
                    }))
                  : fallback;
              })
            : defaults.employeesByCompany,
          companyData: parsed?.companyData
            ? normalizeCompanyData(parsed.companyData)
            : defaults.companyData,
        };
        next.companyHistoryByCompany = Array.isArray(parsed?.companyHistoryByCompany)
          ? parsed.companyHistoryByCompany.map((entry, companyIndex) => {
              const fallback = createHistoryState(next.companyData[companyIndex]?.tabellenEintraege || {});
              if (!entry || typeof entry !== "object") return fallback;
              const history = Array.isArray(entry.history) && entry.history.length
                ? entry.history.map((snapshot) => normalizeCompanyHistorySnapshot(snapshot))
                : fallback.history;
              const historyIndex = clampNumber(parseInt(entry.historyIndex, 10) || 0, 0, history.length - 1);
              return { history, historyIndex };
            })
          : createCompanyHistoryByCompany(next.companyData);
        return next;
      };

      const parseStoredProject = (parsed) => {
        return migrateProjectState(parsed);
      };

      const parseStoredProjectPayload = (rawValue, fallbackProjectName = "") => {
        const nowIso = new Date().toISOString();
        let parsed = null;
        try {
          parsed = JSON.parse(rawValue);
        } catch (error) {
          return {
            name: fallbackProjectName || "",
            createdAt: nowIso,
            lastModified: nowIso,
            state: null,
            loadable: false,
            error: "parse_error",
          };
        }
        const payload = parsed && typeof parsed === "object" && parsed.state ? parsed : null;
        const stateSource = payload ? payload.state : parsed;
        return {
          name: payload?.name || fallbackProjectName || "",
          createdAt: payload?.createdAt || nowIso,
          lastModified: payload?.lastModified || payload?.createdAt || nowIso,
          state: parseStoredProject(stateSource),
          loadable: true,
          error: null,
        };
      };

      const formatMonthYearFromAbsoluteIndex = (absoluteMonthIndex) => {
        const year = Math.floor(absoluteMonthIndex / 12);
        const month = (absoluteMonthIndex % 12) + 1;
        return `${String(month).padStart(2, "0")}.${year}`;
      };

      const getMonthsByYearFromRange = (startAbsoluteIndex, endAbsoluteIndex) => {
        const monthsByYear = {};
        for (let index = startAbsoluteIndex; index <= endAbsoluteIndex; index += 1) {
          const year = Math.floor(index / 12);
          monthsByYear[year] = (monthsByYear[year] || 0) + 1;
        }
        return monthsByYear;
      };

      const areTableEntriesEqual = (current, next) => {
        const currentKeys = Object.keys(current || {});
        const nextKeys = Object.keys(next || {});
        if (currentKeys.length !== nextKeys.length) return false;
        return currentKeys.every(
          (key) => JSON.stringify(current[key] || {}) === JSON.stringify(next[key] || {})
        );
      };

      const buildTimeline = (startDateValue, duration) => {
        const startDate = parseDate(startDateValue);
        return Array.from({ length: duration }, (_, index) => {
          const date = new Date(startDate.getFullYear(), startDate.getMonth() + index, 1);
          return {
            year: date.getFullYear(),
            month: date.getMonth(),
            label: monthNames[date.getMonth()],
          };
        });
      };

      const groupYears = (timeline) => {
        return timeline.reduce((acc, entry) => {
          const last = acc[acc.length - 1];
          if (!last || last.year !== entry.year) {
            acc.push({ year: entry.year, span: 1 });
          } else {
            last.span += 1;
          }
          return acc;
        }, []);
      };


      const App = () => {
        const [startDate, setStartDate] = useState(DEFAULT_START_DATE);
        const [durationMonths, setDurationMonths] = useState(DEFAULT_DURATION_MONTHS);
        const [companyCount, setCompanyCount] = useState(DEFAULT_ACTIVE_COMPANY_COUNT);
        const [companyNames, setCompanyNames] = useState(DEFAULT_COMPANY_NAMES);
        const [workPackages, setWorkPackages] = useState(() => createDefaultWorkPackages());
        const [employeesByCompany, setEmployeesByCompany] = useState(() =>
          createEmployeesByCompany()
        );
        const [companyData, setCompanyData] = useState(() => normalizeCompanyData());
        const [companyHistoryByCompany, setCompanyHistoryByCompany] = useState(() =>
          createCompanyHistoryByCompany()
        );
        const [pendingDelete, setPendingDelete] = useState(null);
        const [pendingEmployeeDelete, setPendingEmployeeDelete] = useState(null);
        const [focusedCurrencyField, setFocusedCurrencyField] = useState(null);
        const [rowHeights, setRowHeights] = useState({});
        const [ganttScrollLeft, setGanttScrollLeft] = useState(0);
        const [ganttViewportWidth, setGanttViewportWidth] = useState(0);
        const [ganttScrollWidth, setGanttScrollWidth] = useState(0);
        const ganttScrollContainerRef = useRef(null);
        const [currentProjectName, setCurrentProjectName] = useState("");
        const [projectRecords, setProjectRecords] = useState([]);
        const [newProjectModalOpen, setNewProjectModalOpen] = useState(false);
        const [loadProjectModalOpen, setLoadProjectModalOpen] = useState(false);
        const [newProjectName, setNewProjectName] = useState("");
        const [projectSearchTerm, setProjectSearchTerm] = useState("");
        const [projectError, setProjectError] = useState("");
        const [storageError, setStorageError] = useState("");
        const [saveState, setSaveState] = useState("gespeichert");
        const [fullscreenCompanyIndex, setFullscreenCompanyIndex] = useState(null);
        const [zimPdfModalState, setZimPdfModalState] = useState({
          open: false,
          companyIndex: null,
          companyName: "",
          fieldNames: [],
          mappings: [],
          unmappedFields: [],
          acronymInPdf: "",
          acronymStatus: "unknown",
          warningAccepted: false,
          analysisMessage: "",
          analysisError: "",
          noFormFields: false,
          uploadedFile: null,
          downloadUrl: "",
          downloadName: "",
        });
        const hasInitializedRef = useRef(false);
        const debounceSaveRef = useRef(null);

        useEffect(() => {
          return () => {
            if (zimPdfModalState.downloadUrl) {
              URL.revokeObjectURL(zimPdfModalState.downloadUrl);
            }
          };
        }, [zimPdfModalState.downloadUrl]);

        const applyProjectState = useCallback((projectState) => {
          const parsed = parseStoredProject(projectState);
          setWorkPackages(parsed.workPackages);
          setCompanyNames(parsed.companyNames);
          setCompanyCount(parsed.companyCount);
          setStartDate(parsed.startDate);
          setDurationMonths(parsed.durationMonths);
          setEmployeesByCompany(parsed.employeesByCompany);
          setCompanyData(parsed.companyData);
          setCompanyHistoryByCompany(
            Array.isArray(parsed.companyHistoryByCompany)
              ? parsed.companyHistoryByCompany
              : createCompanyHistoryByCompany(parsed.companyData)
          );
          setPendingDelete(null);
          setPendingEmployeeDelete(null);
        }, []);

        const collectProjectState = useCallback(
          () => ({
            schemaVersion: PROJECT_SCHEMA_VERSION,
            workPackages,
            companyCount,
            companyNames,
            startDate,
            durationMonths,
            employeesByCompany,
            companyData,
            companyHistoryByCompany,
          }),
          [
            workPackages,
            companyCount,
            companyNames,
            startDate,
            durationMonths,
            employeesByCompany,
            companyData,
            companyHistoryByCompany,
          ]
        );

        const persistProject = useCallback((projectName, projectState, options = {}) => {
          const key = getProjectStorageKey(projectName);
          const tempKey = `${key}:tmp`;
          const existingRaw = localStorage.getItem(key);
          const existingPayload = existingRaw
            ? parseStoredProjectPayload(existingRaw, projectName)
            : null;
          const createdAt = options.createdAt || existingPayload?.createdAt || new Date().toISOString();
          const lastModified = options.lastModified || new Date().toISOString();
          const sanitizedState = parseStoredProject(projectState);
          const payload = {
            projectId: projectName,
            name: projectName,
            createdAt,
            lastModified,
            state: sanitizedState,
          };

          localStorage.setItem(tempKey, JSON.stringify(payload));
          localStorage.setItem(key, localStorage.getItem(tempKey));
          localStorage.removeItem(tempKey);
          localStorage.setItem(CURRENT_PROJECT_KEY, projectName);
          setProjectRecords((prev) => {
            const withoutCurrent = prev.filter((entry) => entry.name !== projectName);
            const next = [...withoutCurrent, { name: projectName, createdAt, lastModified, loadable: true, error: null }]
              .sort((a, b) => new Date(b.lastModified).getTime() - new Date(a.lastModified).getTime());
            localStorage.setItem(PROJECTS_INDEX_KEY, JSON.stringify(next.map(({ name, createdAt, lastModified }) => ({ name, createdAt, lastModified }))));
            return next;
          });

          fetch("/api/project/save", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
            keepalive: true,
          }).catch(() => {});
        }, []);

        const saveNow = useCallback((overrideState = null) => {
          if (!hasInitializedRef.current || !currentProjectName) return;
          try {
            const snapshot = overrideState || collectProjectState();
            persistProject(currentProjectName, snapshot);
            setSaveState("gespeichert");
          } catch (error) {
            console.warn("Projekt konnte nicht gespeichert werden", error);
            setStorageError("Projekt konnte nicht gespeichert werden.");
          }
        }, [collectProjectState, currentProjectName, persistProject]);

        useEffect(() => {
          const ensureCryoVision = async (records) => {
            const cryoRecord = records.find((entry) => entry.name === SEED_PROJECT_NAME);
            if (cryoRecord && cryoRecord.loadable) return records;
            let seedState = null;
            try {
              const response = await fetch(CRYOVISION_SEED_PATH, { cache: "no-store" });
              if (response.ok) {
                const seedJson = await response.json();
                if (seedJson?.template === "cryoVisionBuiltIn") {
                  seedState = buildSeedCryoVisionState();
                } else if (Array.isArray(seedJson?.workPackages) && seedJson.workPackages.length) {
                  seedState = parseStoredProject(seedJson);
                }
              }
            } catch (error) {
              seedState = null;
            }
            const fallbackSeed = seedState || buildSeedCryoVisionState();
            const timestamp = new Date().toISOString();
            persistProject(SEED_PROJECT_NAME, fallbackSeed, {
              createdAt: cryoRecord?.createdAt || timestamp,
              lastModified: timestamp,
            });
            return [
              ...records.filter((entry) => entry.name !== SEED_PROJECT_NAME),
              {
                name: SEED_PROJECT_NAME,
                createdAt: cryoRecord?.createdAt || timestamp,
                lastModified: timestamp,
                loadable: true,
                error: null,
              },
            ];
          };

          (async () => {
            try {
              const rawIndex = localStorage.getItem(PROJECTS_INDEX_KEY);
              const parsedIndex = rawIndex ? JSON.parse(rawIndex) : [];
              const nowIso = new Date().toISOString();
              const indexRecords = Array.isArray(parsedIndex)
                ? parsedIndex
                    .map((entry) => {
                      if (typeof entry === "string") {
                        return { name: entry.trim(), createdAt: nowIso, lastModified: nowIso };
                      }
                      if (entry && typeof entry === "object" && entry.name) {
                        return {
                          name: `${entry.name}`.trim(),
                          createdAt: entry.createdAt || nowIso,
                          lastModified: entry.lastModified || entry.createdAt || nowIso,
                        };
                      }
                      return null;
                    })
                    .filter((entry) => entry && entry.name)
                : [];

              const recordsWithStatus = indexRecords.map((record) => {
                const key = getProjectStorageKey(record.name);
                const raw = localStorage.getItem(key);
                if (!raw) {
                  return { ...record, loadable: false, error: "missing" };
                }
                const payload = parseStoredProjectPayload(raw, record.name);
                if (!payload.loadable) {
                  return { ...record, loadable: false, error: payload.error };
                }
                localStorage.setItem(
                  key,
                  JSON.stringify({
                    projectId: record.name,
                    name: record.name,
                    createdAt: record.createdAt || payload.createdAt,
                    lastModified: record.lastModified || payload.lastModified,
                    state: payload.state,
                  })
                );
                return { ...record, loadable: true, error: null };
              });

              const withCryo = await ensureCryoVision(recordsWithStatus);
              const nextRecords = withCryo
                .sort((a, b) => new Date(b.lastModified).getTime() - new Date(a.lastModified).getTime());

              localStorage.setItem(
                PROJECTS_INDEX_KEY,
                JSON.stringify(nextRecords.map(({ name, createdAt, lastModified }) => ({ name, createdAt, lastModified })))
              );
              setProjectRecords(nextRecords);
              setCurrentProjectName("");
              localStorage.removeItem(CURRENT_PROJECT_KEY);
              setStorageError("");
              hasInitializedRef.current = true;
            } catch (error) {
              console.warn("Projektliste konnte nicht geladen werden", error);
              setStorageError("Projektliste konnte nicht geladen werden.");
              hasInitializedRef.current = true;
            }
          })();
        }, [persistProject]);

        const projectStateSnapshot = collectProjectState();

        useEffect(() => {
          if (!hasInitializedRef.current || !currentProjectName) return;
          setSaveState("speichert...");
          if (debounceSaveRef.current) {
            clearTimeout(debounceSaveRef.current);
          }
          debounceSaveRef.current = setTimeout(() => {
            saveNow(projectStateSnapshot);
          }, AUTO_SAVE_DEBOUNCE_MS);

          return () => {
            if (debounceSaveRef.current) {
              clearTimeout(debounceSaveRef.current);
            }
          };
        }, [currentProjectName, projectStateSnapshot, saveNow]);

        useEffect(() => {
          const handleBeforeUnload = () => {
            if (!hasInitializedRef.current || !currentProjectName) return;
            const snapshot = collectProjectState();
            saveNow(snapshot);
          };
          window.addEventListener("beforeunload", handleBeforeUnload);
          return () => {
            window.removeEventListener("beforeunload", handleBeforeUnload);
          };
        }, [collectProjectState, currentProjectName, saveNow]);

        const createNewProject = () => {
          const trimmedName = newProjectName.trim();
          if (!trimmedName) {
            setProjectError("Projektname ist erforderlich.");
            return;
          }
          if (projectRecords.some((entry) => entry.name.toLowerCase() === trimmedName.toLowerCase())) {
            setProjectError("Projektname existiert bereits. Bitte anderen Namen wählen.");
            return;
          }
          const initialState = buildDefaultProjectState();
          try {
            persistProject(trimmedName, initialState);
            applyProjectState(initialState);
            setCurrentProjectName(trimmedName);
            setProjectError("");
            setNewProjectModalOpen(false);
            setNewProjectName("");
            setSaveState("gespeichert");
          } catch (error) {
            console.warn("Neues Projekt konnte nicht erstellt werden", error);
            setProjectError("Projekt konnte nicht erstellt werden.");
          }
        };

        const handleProjectLoad = (projectName) => {
          if (!projectName) return;
          try {
            const raw = localStorage.getItem(getProjectStorageKey(projectName));
            if (!raw) throw new Error("Projekt fehlt");
            const parsedPayload = parseStoredProjectPayload(raw, projectName);
            if (!parsedPayload.loadable || !parsedPayload.state) {
              throw new Error("Projekt konnte nicht geparst werden");
            }
            setCurrentProjectName(projectName);
            localStorage.setItem(CURRENT_PROJECT_KEY, projectName);
            applyProjectState(parsedPayload.state);
            setLoadProjectModalOpen(false);
            setStorageError("");
            setSaveState("gespeichert");
          } catch (error) {
            console.warn("Projekt konnte nicht geladen werden", error);
            setStorageError("Projekt konnte nicht geladen werden.");
            setProjectRecords((prev) =>
              prev.map((entry) =>
                entry.name === projectName ? { ...entry, loadable: false, error: "parse_error" } : entry
              )
            );
          }
        };

        const filteredProjectRecords = useMemo(() => {
          const term = projectSearchTerm.trim().toLowerCase();
          return projectRecords
            .filter((entry) => entry.name.toLowerCase().includes(term))
            .sort((a, b) => new Date(b.lastModified).getTime() - new Date(a.lastModified).getTime());
        }, [projectRecords, projectSearchTerm]);

        const restoreCryoVisionProject = async () => {
          let seedState = null;
          try {
            const response = await fetch(CRYOVISION_SEED_PATH, { cache: "no-store" });
            if (response.ok) {
              const seedJson = await response.json();
              seedState = parseStoredProject(seedJson);
            }
          } catch (error) {
            seedState = null;
          }
          const now = new Date().toISOString();
          persistProject(SEED_PROJECT_NAME, seedState || buildSeedCryoVisionState(), {
            createdAt: now,
            lastModified: now,
          });
          setStorageError("");
        };

        const activeCompanyIndexes = useMemo(
          () => Array.from({ length: companyCount }, (_, index) => index),
          [companyCount]
        );

        const timeline = useMemo(
          () => buildTimeline(startDate, durationMonths),
          [startDate, durationMonths]
        );
        const yearSegments = useMemo(() => groupYears(timeline), [timeline]);
        const projectYears = useMemo(
          () => Array.from(new Set(timeline.map((entry) => entry.year))),
          [timeline]
        );

        const employeeCostsByCompany = useMemo(() => {
          return employeesByCompany.map((companyEmployees) =>
            companyEmployees.map((employee) => {
              const annualCostBase = parseNumber(employee.annualSalary);
              const typicalHours = parseNumber(employee.weeklyHours);
              const actualHours = parseNumber(employee.actualHours);
              const hourFactor =
                typicalHours > 0 ? actualHours / typicalHours : 1;
              const partTimeFactor = clampNumber(
                parseNumber(employee.partTimeFactor),
                0,
                1
              );
              const projectFactor = clampNumber(
                parseNumber(employee.projectPercent) / 100,
                0,
                1
              );
              const annualProjectCost =
                annualCostBase * hourFactor * partTimeFactor * projectFactor;
              const costPerPM = annualProjectCost / 12;
              return {
                annualProjectCost,
                costPerPM,
              };
            })
          );
        }, [employeesByCompany]);

        const rows = useMemo(() => {
          const list = [];
          workPackages.forEach((wp, wpIndex) => {
            list.push({ type: "wp", wpIndex, subIndex: null });
            wp.sub.forEach((_, subIndex) => {
              list.push({ type: "sub", wpIndex, subIndex });
            });
            list.push({ type: "summary", wpIndex, subIndex: null });
          });
          list.push({ type: "total" });
          return list;
        }, [workPackages]);

        const workPackageRows = useMemo(() => {
          const list = [];
          workPackages.forEach((wp, wpIndex) => {
            list.push({
              id: wp.id,
              number: `${wpIndex + 1}`,
              title: wp.title,
              pmByCompany: wp.pm,
            });
            wp.sub.forEach((sub, subIndex) => {
              list.push({
                id: sub.id,
                number: `${wpIndex + 1}.${subIndex + 1}`,
                title: sub.title,
                pmByCompany: sub.pm,
              });
            });
          });
          return list;
        }, [workPackages]);

        const normalizePmValue = (value) => {
          if (value === "" || value === null || value === undefined) return 0;
          if (typeof value === "number") return value;
          const normalized = `${value}`.trim().replace(",", ".");
          const parsed = Number.parseFloat(normalized);
          return Number.isNaN(parsed) ? 0 : parsed;
        };

        const filteredWorkPackageRowsByCompany = useMemo(() => {
          return activeCompanyIndexes.reduce((acc, companyIndex) => {
            acc[companyIndex] = workPackageRows.filter(
              (row) => isSubWorkPackageNumber(row.number) && normalizePmValue(row.pmByCompany?.[companyIndex]) > 0
            );
            return acc;
          }, {});
        }, [workPackageRows, activeCompanyIndexes]);

        useEffect(() => {
          setCompanyData((prev) => {
            let hasChanges = false;
            const next = prev.map((entry, companyIndex) => {
              if (!activeCompanyIndexes.includes(companyIndex)) {
                return entry;
              }
              const rows = filteredWorkPackageRowsByCompany[companyIndex] || [];
              const existingEntries = entry.tabellenEintraege || {};
              const updatedEntries = rows.reduce((acc, row) => {
                const currentEntry = existingEntries[row.id] || {};
                acc[row.id] = currentEntry;
                return acc;
              }, {});

              if (!areTableEntriesEqual(existingEntries, updatedEntries)) {
                hasChanges = true;
                return { ...entry, tabellenEintraege: updatedEntries };
              }
              return entry;
            });
            if (hasChanges) {
              setCompanyHistoryByCompany((prevHistory) => {
                const nextHistory = [...prevHistory];
                next.forEach((entry, companyIndex) => {
                  if (!activeCompanyIndexes.includes(companyIndex)) return;
                  const existing = prevHistory[companyIndex] || createHistoryState({});
                  const existingSnapshot = normalizeCompanyHistorySnapshot(
                    existing.history[existing.historyIndex] || {}
                  );
                  if (
                    areTableEntriesEqual(
                      existingSnapshot.tabellenEintraege || {},
                      entry.tabellenEintraege || {}
                    )
                  ) {
                    return;
                  }
                  nextHistory[companyIndex] = createHistoryState(entry.tabellenEintraege || {});
                });
                return nextHistory;
              });
            }
            return hasChanges ? next : prev;
          });
        }, [filteredWorkPackageRowsByCompany, activeCompanyIndexes]);

        const updateWpTitle = (wpIndex, value) => {
          setWorkPackages((prev) => {
            const next = [...prev];
            next[wpIndex] = { ...next[wpIndex], title: value };
            return next;
          });
        };

        const updateSubTitle = (wpIndex, subIndex, value) => {
          setWorkPackages((prev) => {
            const next = [...prev];
            const wp = { ...next[wpIndex] };
            const sub = [...wp.sub];
            sub[subIndex] = { ...sub[subIndex], title: value };
            wp.sub = sub;
            next[wpIndex] = wp;
            return next;
          });
        };

        const updatePm = (wpIndex, subIndex, companyIndex, value) => {
          const numeric = value === "" ? "" : parseNumber(value);
          if (subIndex === null) return;
          setWorkPackages((prev) => {
            const next = [...prev];
            const wp = { ...next[wpIndex] };
            const sub = [...wp.sub];
            const subItem = { ...sub[subIndex] };
            const pm = [...subItem.pm];
            pm[companyIndex] = numeric;
            subItem.pm = pm;
            sub[subIndex] = subItem;
            wp.sub = sub;
            next[wpIndex] = wp;
            return next;
          });
        };

        const addWp = () => {
          setWorkPackages((prev) => {
            if (prev.length >= MAX_WP) return prev;
            return [...prev, createWp(prev.length)];
          });
        };

        const addSub = (wpIndex) => {
          setWorkPackages((prev) => {
            const next = [...prev];
            const wp = { ...next[wpIndex] };
            if (wp.sub.length >= MAX_SUB) return prev;
            wp.sub = [...wp.sub, createSub(wpIndex, wp.sub.length)];
            next[wpIndex] = wp;
            return next;
          });
        };

        const requestDelete = (type, wpIndex, subIndex = null) => {
          setPendingDelete({ type, wpIndex, subIndex });
        };

        const cancelDelete = () => setPendingDelete(null);

        const confirmDelete = () => {
          if (!pendingDelete) return;
          const { type, wpIndex, subIndex } = pendingDelete;
          setWorkPackages((prev) => {
            const next = [...prev];
            if (type === "wp") {
              next.splice(wpIndex, 1);
            } else if (type === "sub") {
              const wp = { ...next[wpIndex] };
              const sub = [...wp.sub];
              sub.splice(subIndex, 1);
              wp.sub = sub;
              next[wpIndex] = wp;
            }
            return next.length ? next : createDefaultWorkPackages();
          });
          setPendingDelete(null);
        };

        const addEmployee = (companyIndex) => {
          setEmployeesByCompany((prev) => {
            const next = [...prev];
            const companyEmployees = [...(next[companyIndex] || [])];
            if (companyEmployees.length >= MAX_EMPLOYEES) return prev;
            companyEmployees.push(createEmployee());
            next[companyIndex] = companyEmployees;
            return next;
          });
        };

        const requestEmployeeRemove = (companyIndex) => {
          const companyEmployees = employeesByCompany[companyIndex] || [];
          if (!companyEmployees.length) return;
          setPendingEmployeeDelete(companyIndex);
        };

        const cancelEmployeeRemove = () => setPendingEmployeeDelete(null);

        const confirmEmployeeRemove = () => {
          if (pendingEmployeeDelete === null) return;
          setEmployeesByCompany((prev) => {
            const next = [...prev];
            const companyEmployees = [...(next[pendingEmployeeDelete] || [])];
            companyEmployees.pop();
            next[pendingEmployeeDelete] = companyEmployees.length
              ? companyEmployees
              : [createEmployee()];
            return next;
          });
          setPendingEmployeeDelete(null);
        };

        const updateEmployeeField = (companyIndex, employeeIndex, field, value) => {
          setEmployeesByCompany((prev) => {
            const next = [...prev];
            const companyEmployees = [...(next[companyIndex] || [])];
            companyEmployees[employeeIndex] = {
              ...companyEmployees[employeeIndex],
              [field]: value,
            };
            next[companyIndex] = companyEmployees;
            return next;
          });
        };

        const updateEmployeeNumber = (
          companyIndex,
          employeeIndex,
          field,
          value,
          min,
          max = null
        ) => {
          const numeric = parseNumber(value);
          const clamped = max === null ? Math.max(min, numeric) : clampNumber(numeric, min, max);
          updateEmployeeField(companyIndex, employeeIndex, field, clamped);
        };

        const updateCompanyTableEntry = (companyIndex, rowId, field, value) => {
          setCompanyData((prev) => {
            const next = [...prev];
            const entry = { ...next[companyIndex] };
            const tabellenEintraege = { ...entry.tabellenEintraege };
            const rowEntry = { ...(tabellenEintraege[rowId] || {}) };
            if ((rowEntry[field] || "") === (value || "")) return prev;
            rowEntry[field] = value;
            tabellenEintraege[rowId] = rowEntry;
            entry.tabellenEintraege = tabellenEintraege;
            next[companyIndex] = entry;
            const snapshot = createCompanyHistorySnapshot(tabellenEintraege);
            setCompanyHistoryByCompany((prevHistory) => {
              const nextHistory = [...prevHistory];
              const current = nextHistory[companyIndex] || createHistoryState({});
              const trimmedHistory = current.history.slice(0, current.historyIndex + 1);
              trimmedHistory.push(snapshot);
              let history = trimmedHistory;
              if (history.length > MAX_HISTORY_STEPS) {
                history = history.slice(history.length - MAX_HISTORY_STEPS);
              }
              nextHistory[companyIndex] = {
                history,
                historyIndex: history.length - 1,
              };
              return nextHistory;
            });
            return next;
          });
        };

        const getCompanyPmSnapshot = (companyIndex, sourceWorkPackages = workPackages) => {
          const pmByRowId = {};
          sourceWorkPackages.forEach((wp) => {
            pmByRowId[wp.id] = wp.pm?.[companyIndex] ?? "";
            wp.sub.forEach((sub) => {
              pmByRowId[sub.id] = sub.pm?.[companyIndex] ?? "";
            });
          });
          return { pmByRowId };
        };

        const applyCompanyPmSnapshot = (companyIndex, pmSnapshot) => {
          if (!pmSnapshot?.pmByRowId) return;
          const pmByRowId = pmSnapshot.pmByRowId;
          setWorkPackages((prev) =>
            prev.map((wp) => {
              return {
                ...wp,
                pm: Array(5).fill(""),
                sub: wp.sub.map((sub) => {
                  const nextSubPm = [...sub.pm];
                  if (Object.prototype.hasOwnProperty.call(pmByRowId, sub.id)) {
                    nextSubPm[companyIndex] = pmByRowId[sub.id];
                  }
                  return {
                    ...sub,
                    pm: nextSubPm,
                  };
                }),
              };
            })
          );
        };

        const applyCompanySnapshot = (companyIndex, snapshot) => {
          const normalizedSnapshot = normalizeCompanyHistorySnapshot(snapshot);
          setCompanyData((prev) => {
            const next = [...prev];
            next[companyIndex] = {
              ...next[companyIndex],
              tabellenEintraege: cloneTableEntries(normalizedSnapshot.tabellenEintraege),
            };
            return next;
          });
          applyCompanyPmSnapshot(companyIndex, normalizedSnapshot.pmSnapshot);
        };

        const commitCompanyHistoryStep = (companyIndex, beforeSnapshot, afterSnapshot) => {
          setCompanyHistoryByCompany((prevHistory) => {
            const nextHistory = [...prevHistory];
            const current = nextHistory[companyIndex] || createHistoryState({});
            const trimmedHistory = current.history.slice(0, current.historyIndex + 1);
            if (trimmedHistory.length) {
              trimmedHistory[trimmedHistory.length - 1] = normalizeCompanyHistorySnapshot(
                beforeSnapshot
              );
            } else {
              trimmedHistory.push(normalizeCompanyHistorySnapshot(beforeSnapshot));
            }
            trimmedHistory.push(normalizeCompanyHistorySnapshot(afterSnapshot));
            let history = trimmedHistory;
            if (history.length > MAX_HISTORY_STEPS) {
              history = history.slice(history.length - MAX_HISTORY_STEPS);
            }
            nextHistory[companyIndex] = {
              history,
              historyIndex: history.length - 1,
            };
            return nextHistory;
          });
        };

        const undoCompanyAssignment = (companyIndex) => {
          let snapshotToApply = null;
          setCompanyHistoryByCompany((prev) => {
            const next = [...prev];
            const companyHistory = next[companyIndex];
            if (!companyHistory || companyHistory.historyIndex <= 0) return prev;
            const historyIndex = companyHistory.historyIndex - 1;
            snapshotToApply = normalizeCompanyHistorySnapshot(companyHistory.history[historyIndex]);
            next[companyIndex] = {
              ...companyHistory,
              historyIndex,
            };
            return next;
          });
          if (snapshotToApply) {
            applyCompanySnapshot(companyIndex, snapshotToApply);
          }
        };

        const redoCompanyAssignment = (companyIndex) => {
          let snapshotToApply = null;
          setCompanyHistoryByCompany((prev) => {
            const next = [...prev];
            const companyHistory = next[companyIndex];
            if (
              !companyHistory ||
              companyHistory.historyIndex >= companyHistory.history.length - 1
            ) {
              return prev;
            }
            const historyIndex = companyHistory.historyIndex + 1;
            snapshotToApply = normalizeCompanyHistorySnapshot(companyHistory.history[historyIndex]);
            next[companyIndex] = {
              ...companyHistory,
              historyIndex,
            };
            return next;
          });
          if (snapshotToApply) {
            applyCompanySnapshot(companyIndex, snapshotToApply);
          }
        };

        const getAutoPlanningLocks = (companyIndex) => ({
          ...DEFAULT_AUTO_LOCKS,
          ...(companyData[companyIndex]?.autoPlanningLocks || {}),
        });

        const runAutoProjectPlanning = (companyIndex) => {
          const companyRows = filteredWorkPackageRowsByCompany[companyIndex] || [];
          const companyEmployees = employeesByCompany[companyIndex] || [];
          const locks = getAutoPlanningLocks(companyIndex);
          const shouldOptimizeEmployees = !locks.employeeAssignment;
          const shouldOptimizeDates = !locks.workPackageDates;
          const shouldOptimizePm = !locks.personMonths;
          if (!companyRows.length) return;
          if (!shouldOptimizeEmployees && !shouldOptimizeDates && !shouldOptimizePm) return;
          if (shouldOptimizeEmployees && !companyEmployees.length) return;

          const projectStart = parseDate(startDate);
          const projectStartIndex = projectStart.getFullYear() * 12 + projectStart.getMonth();
          const projectEndIndex = projectStartIndex + durationMonths - 1;
          if (projectEndIndex < projectStartIndex) return;

          const rowsToPlan = [...companyRows].sort((a, b) => {
            return `${a.number}`.localeCompare(`${b.number}`, "de", { numeric: true });
          });
          const rowsWithPm = rowsToPlan
            .map((row) => ({
              row,
              pmDemand: normalizePmValue(row.pmByCompany?.[companyIndex]),
            }))
            .filter((entry) => entry.pmDemand > 0);
          if (!rowsWithPm.length) return;

          const existingEntries = companyData[companyIndex]?.tabellenEintraege || {};
          const plannedByRowId = {};
          if (shouldOptimizeDates) {
            const rowCount = rowsWithPm.length;
            rowsWithPm.forEach((entry, index) => {
              const isFirst = index === 0;
              const isLast = index === rowCount - 1;
              const duration = clampNumber(Math.ceil(entry.pmDemand), 1, 10);
              const baseStart =
                rowCount === 1
                  ? projectStartIndex
                  : Math.round(
                      projectStartIndex +
                        ((projectEndIndex - projectStartIndex) * index) / (rowCount - 1)
                    );
              const previous = index > 0 ? plannedByRowId[rowsWithPm[index - 1].row.id] : null;
              const minStart = isFirst
                ? projectStartIndex
                : previous
                  ? parseMonthYear(previous.start).year * 12 + parseMonthYear(previous.start).month
                  : projectStartIndex;
              let start = clampNumber(
                Math.max(baseStart, minStart),
                projectStartIndex,
                Math.max(projectStartIndex, projectEndIndex - duration + 1)
              );
              if (isFirst) {
                start = projectStartIndex;
              }
              let end = clampNumber(start + duration - 1, start, projectEndIndex);
              if (isLast) {
                end = projectEndIndex;
                start = clampNumber(
                  end - duration + 1,
                  Math.max(projectStartIndex, minStart),
                  end
                );
              }
              plannedByRowId[entry.row.id] = {
                start: formatMonthYearFromAbsoluteIndex(start),
                ende: formatMonthYearFromAbsoluteIndex(end),
              };
            });
          } else {
            rowsWithPm.forEach((entry) => {
              const current = existingEntries[entry.row.id] || {};
              plannedByRowId[entry.row.id] = {
                start: current.start || "",
                ende: current.ende || "",
              };
            });
          }

          const employeeOrder = companyEmployees
            .map((employee, employeeIndex) => ({
              employeeIndex,
              annualSalary: parseNumber(employee.annualSalary),
              annualMaxPm:
                YEAR_CAP_PM * (getEffectiveProjectPercent(employee.projectPercent) / 100),
            }))
            .sort((a, b) => b.annualSalary - a.annualSalary || a.employeeIndex - b.employeeIndex);

          const zuschlagInput = parseNumber(companyData[companyIndex]?.zuschlagsfaktorPercent);
          const maximalbetrag = parseNumber(companyData[companyIndex]?.maximalbetrag);
          const personnelCostTarget =
            1 + zuschlagInput / 100 > 0
              ? maximalbetrag / (1 + zuschlagInput / 100)
              : Number.POSITIVE_INFINITY;

          const buildYearlyUsage = () =>
            employeeOrder.reduce((acc, employee) => {
              acc[employee.employeeIndex] = {};
              return acc;
            }, {});
          const yearlyUsage = buildYearlyUsage();
          const rowPlanningData = {};

          const isWithinCapacity = (employeeIndex, pmByYear, usageSnapshot = yearlyUsage) => {
            const employee = employeeOrder.find((entry) => entry.employeeIndex === employeeIndex);
            if (!employee) return false;
            return Object.entries(pmByYear).every(([year, pmValue]) => {
              const alreadyUsed = usageSnapshot[employeeIndex]?.[year] || 0;
              return alreadyUsed + pmValue <= employee.annualMaxPm + 1e-9;
            });
          };

          const applyUsage = (
            employeeIndex,
            pmByYear,
            multiplier = 1,
            usageSnapshot = yearlyUsage
          ) => {
            Object.entries(pmByYear).forEach(([year, pmValue]) => {
              usageSnapshot[employeeIndex][year] =
                (usageSnapshot[employeeIndex][year] || 0) + pmValue * multiplier;
            });
          };

          const assignments = {};
          let plannedPersonnelCosts = 0;

          const getStartEndMonthIndex = (assignment) => {
            const parsedStart = parseMonthYear(assignment.start);
            const parsedEnd = parseMonthYear(assignment.ende);
            if (!parsedStart || !parsedEnd) return null;
            const start = parsedStart.year * 12 + parsedStart.month;
            const end = parsedEnd.year * 12 + parsedEnd.month;
            if (end < start) return null;
            return { start, end };
          };

          rowsWithPm.forEach(({ row, pmDemand }) => {
            const dateAssignment = plannedByRowId[row.id] || {};
            const existingRowEntry = existingEntries[row.id] || {};

            if (!shouldOptimizeEmployees) {
              assignments[row.id] = {
                ...dateAssignment,
                mitarbeiterNummer: existingRowEntry.mitarbeiterNummer || "",
              };
              return;
            }

            const span = getStartEndMonthIndex(dateAssignment);
            if (!span) return;
            const monthsByYear = getMonthsByYearFromRange(span.start, span.end);
            const totalMonths = Math.max(1, span.end - span.start + 1);
            const pmPerMonth = pmDemand / totalMonths;
            const pmByYear = Object.entries(monthsByYear).reduce((acc, [year, months]) => {
              acc[year] = pmPerMonth * months;
              return acc;
            }, {});

            rowPlanningData[row.id] = {
              pmDemand,
              pmByYear,
            };

            const candidates = [...employeeOrder]
              .filter((employee) => isWithinCapacity(employee.employeeIndex, pmByYear))
              .sort((a, b) => a.annualSalary - b.annualSalary || a.employeeIndex - b.employeeIndex);
            if (!candidates.length) return;

            const selectedEmployee = candidates[0];
            applyUsage(selectedEmployee.employeeIndex, pmByYear);
            plannedPersonnelCosts += pmDemand * (selectedEmployee.annualSalary / 12);

            assignments[row.id] = {
              ...dateAssignment,
              mitarbeiterNummer: `${selectedEmployee.employeeIndex + 1}`,
            };
          });

          if (shouldOptimizeEmployees) {
            let improved = true;
            while (improved) {
              improved = false;
              let bestUpgrade = null;

              Object.entries(assignments).forEach(([rowId, assignment]) => {
                const rowData = rowPlanningData[rowId];
                const currentEmployeeNumber = parseInt(assignment.mitarbeiterNummer, 10);
                if (!rowData || !currentEmployeeNumber) return;
                const currentEmployeeIndex = currentEmployeeNumber - 1;
                const currentEmployee = employeeOrder.find(
                  (employee) => employee.employeeIndex === currentEmployeeIndex
                );
                if (!currentEmployee) return;

                employeeOrder
                  .filter((candidate) => candidate.annualSalary > currentEmployee.annualSalary)
                  .forEach((candidate) => {
                    applyUsage(currentEmployeeIndex, rowData.pmByYear, -1);
                    const canUseCandidate = isWithinCapacity(candidate.employeeIndex, rowData.pmByYear);
                    applyUsage(currentEmployeeIndex, rowData.pmByYear, 1);
                    if (!canUseCandidate) return;

                    const oldCost = rowData.pmDemand * (currentEmployee.annualSalary / 12);
                    const newCost = rowData.pmDemand * (candidate.annualSalary / 12);
                    const nextCost = plannedPersonnelCosts - oldCost + newCost;

                    const currentDistance = Math.abs(plannedPersonnelCosts - personnelCostTarget);
                    const nextDistance = Math.abs(nextCost - personnelCostTarget);
                    const improvesDistance =
                      nextDistance < currentDistance - 1e-9 ||
                      (Math.abs(nextDistance - currentDistance) <= 1e-9 &&
                        plannedPersonnelCosts <= personnelCostTarget &&
                        nextCost <= personnelCostTarget &&
                        nextCost > plannedPersonnelCosts + 1e-9);
                    if (!improvesDistance) return;

                    const candidateUpgrade = {
                      rowId,
                      currentEmployeeIndex,
                      targetEmployeeIndex: candidate.employeeIndex,
                      nextDistance,
                      nextCost,
                      costDelta: newCost - oldCost,
                    };

                    if (!bestUpgrade) {
                      bestUpgrade = candidateUpgrade;
                      return;
                    }
                    if (candidateUpgrade.nextDistance < bestUpgrade.nextDistance - 1e-9) {
                      bestUpgrade = candidateUpgrade;
                      return;
                    }
                    if (
                      Math.abs(candidateUpgrade.nextDistance - bestUpgrade.nextDistance) <= 1e-9 &&
                      candidateUpgrade.nextCost <= personnelCostTarget &&
                      bestUpgrade.nextCost > personnelCostTarget
                    ) {
                      bestUpgrade = candidateUpgrade;
                      return;
                    }
                    if (
                      Math.abs(candidateUpgrade.nextDistance - bestUpgrade.nextDistance) <= 1e-9 &&
                      Math.abs(candidateUpgrade.costDelta) < Math.abs(bestUpgrade.costDelta)
                    ) {
                      bestUpgrade = candidateUpgrade;
                    }
                  });
              });

              if (bestUpgrade) {
                const rowData = rowPlanningData[bestUpgrade.rowId];
                applyUsage(bestUpgrade.currentEmployeeIndex, rowData.pmByYear, -1);
                applyUsage(bestUpgrade.targetEmployeeIndex, rowData.pmByYear, 1);
                assignments[bestUpgrade.rowId].mitarbeiterNummer = `${
                  bestUpgrade.targetEmployeeIndex + 1
                }`;
                plannedPersonnelCosts = bestUpgrade.nextCost;
                improved = true;
              }
            }
          }

          const nextEntries = cloneTableEntries(existingEntries);
          Object.entries(assignments).forEach(([rowId, assignment]) => {
            nextEntries[rowId] = {
              ...(nextEntries[rowId] || {}),
              ...assignment,
            };
          });

          const beforeSnapshot = createCompanyHistorySnapshot(
            existingEntries,
            getCompanyPmSnapshot(companyIndex, workPackages)
          );
          const optimizedWorkPackages = shouldOptimizePm
            ? optimizePmWorkPackages(companyIndex, workPackages)
            : workPackages;
          const hasEntriesChanged = !areTableEntriesEqual(existingEntries, nextEntries);
          const hasPmChanged =
            JSON.stringify(getCompanyPmSnapshot(companyIndex, workPackages)) !==
            JSON.stringify(getCompanyPmSnapshot(companyIndex, optimizedWorkPackages));
          if (!hasEntriesChanged && !hasPmChanged) return;

          const afterSnapshot = createCompanyHistorySnapshot(
            nextEntries,
            getCompanyPmSnapshot(companyIndex, optimizedWorkPackages)
          );

          applyCompanySnapshot(companyIndex, afterSnapshot);
          commitCompanyHistoryStep(companyIndex, beforeSnapshot, afterSnapshot);
        };

        const calculateCompanyFundingMetrics = (companyIndex, sourceWorkPackages) => {
          const companyEmployees = employeesByCompany[companyIndex] || [];
          const tabellenEintraege = companyData[companyIndex]?.tabellenEintraege || {};
          const pmTotals = companyEmployees.map(() => 0);

          sourceWorkPackages.forEach((wp) => {
            wp.sub.forEach((sub) => {
              const pmDemand = normalizePmValue(sub.pm?.[companyIndex]);
              if (pmDemand <= 0) return;
              const entry = tabellenEintraege[sub.id] || {};
              const employeeNumber = parseInt(entry.mitarbeiterNummer, 10);
              if (!employeeNumber || employeeNumber < 1) return;
              const employeeIndex = employeeNumber - 1;
              if (employeeIndex < 0 || employeeIndex >= pmTotals.length) return;
              pmTotals[employeeIndex] += pmDemand;
            });
          });

          const personalkosten = companyEmployees.reduce((sum, employee, index) => {
            const annualSalary = parseNumber(employee.annualSalary);
            return sum + (pmTotals[index] || 0) * (annualSalary / 12);
          }, 0);
          const zuschlagInput = parseNumber(companyData[companyIndex]?.zuschlagsfaktorPercent);
          const maximalbetrag = parseNumber(companyData[companyIndex]?.maximalbetrag);
          const projektsummeRoh = personalkosten * (1 + zuschlagInput / 100);
          const projektsummeFinal = Math.min(projektsummeRoh, maximalbetrag);
          const realerZuschlagsfaktor =
            personalkosten > 0 ? ((projektsummeFinal / personalkosten) - 1) * 100 : 0;
          const z = Math.min(realerZuschlagsfaktor, zuschlagInput);
          const utilization = maximalbetrag > 0 ? projektsummeFinal / maximalbetrag : 0;

          return {
            z,
            utilization,
            personalkosten,
          };
        };

        const buildPmIncreaseCandidate = (companyIndex, factor, baseWorkPackages) => {
          let changedCells = 0;
          const nextWorkPackages = baseWorkPackages.map((wp) => ({
            ...wp,
            pm: [...wp.pm],
            sub: wp.sub.map((sub) => {
              const nextSub = {
                ...sub,
                pm: [...sub.pm],
              };
              const oldPm = normalizePmValue(sub.pm?.[companyIndex]);
              if (oldPm > 0) {
                const raw = oldPm * (1 + factor);
                const floored = Math.floor(raw / 0.5) * 0.5;
                const newPm = Math.max(floored, oldPm);
                if (newPm > oldPm + 1e-9) {
                  nextSub.pm[companyIndex] = roundToTwo(newPm);
                  changedCells += 1;
                }
              }
              return nextSub;
            }),
          }));
          return { nextWorkPackages, changedCells };
        };

        const isBetterPmCandidate = (candidate, best) => {
          const tolerance = 1e-9;
          const candidateDistance = Math.abs(candidate.metrics.z - 100);
          const bestDistance = Math.abs(best.metrics.z - 100);
          if (candidateDistance < bestDistance - tolerance) return true;
          if (candidateDistance > bestDistance + tolerance) return false;

          const candidateAtOrBelow = candidate.metrics.z <= 100 + tolerance;
          const bestAtOrBelow = best.metrics.z <= 100 + tolerance;
          if (candidateAtOrBelow && !bestAtOrBelow) return true;
          if (!candidateAtOrBelow && bestAtOrBelow) return false;

          if (candidate.metrics.utilization > best.metrics.utilization + tolerance) return true;
          if (candidate.metrics.utilization < best.metrics.utilization - tolerance) return false;

          if (candidate.metrics.personalkosten > best.metrics.personalkosten + tolerance) return true;
          if (candidate.metrics.personalkosten < best.metrics.personalkosten - tolerance) return false;

          return candidate.factor < best.factor;
        };

        const optimizePmWorkPackages = (companyIndex, sourceWorkPackages) => {
          const maxFactorPercent = 200;
          const factorStepPercent = 5;
          let bestCandidate = {
            factor: 0,
            workPackages: sourceWorkPackages,
            metrics: calculateCompanyFundingMetrics(companyIndex, sourceWorkPackages),
          };

          for (
            let factorPercent = factorStepPercent;
            factorPercent <= maxFactorPercent;
            factorPercent += factorStepPercent
          ) {
            const factor = factorPercent / 100;
            const candidateState = buildPmIncreaseCandidate(companyIndex, factor, sourceWorkPackages);
            if (candidateState.changedCells === 0) {
              continue;
            }
            const candidate = {
              factor,
              workPackages: candidateState.nextWorkPackages,
              metrics: calculateCompanyFundingMetrics(
                companyIndex,
                candidateState.nextWorkPackages
              ),
            };
            if (isBetterPmCandidate(candidate, bestCandidate)) {
              bestCandidate = candidate;
            }
          }
          return bestCandidate.workPackages;
        };

        const updateCompanyField = (companyIndex, field, value) => {
          setCompanyData((prev) => {
            const next = [...prev];
            next[companyIndex] = {
              ...next[companyIndex],
              [field]: value,
            };
            return next;
          });
        };


        const handleGanttSliderChange = (event) => {
          const value = parseInt(event.target.value, 10) || 0;
          setGanttScrollLeft(value);
          if (ganttScrollContainerRef.current) {
            ganttScrollContainerRef.current.scrollLeft = value;
          }
        };

        const handleGanttScroll = (event) => {
          setGanttScrollLeft(event.currentTarget.scrollLeft);
        };

        const sumByCompany = (wp) => {
          return activeCompanyIndexes.map((idx) => {
            return wp.sub.reduce(
              (acc, sub) => acc + normalizePmValue(sub.pm[idx]),
              0
            );
          });
        };

        const totalByCompany = useMemo(() => {
          return activeCompanyIndexes.map((idx) => {
            return workPackages.reduce((acc, wp) => {
              const subValue = wp.sub.reduce(
                (inner, sub) => inner + normalizePmValue(sub.pm[idx]),
                0
              );
              return acc + subValue;
            }, 0);
          });
        }, [workPackages, activeCompanyIndexes]);

        const DESCRIPTION_COLUMN_PX = 460;
        const COMPANY_COLUMN_PX = 130;

        const employeeGridTemplate =
          "minmax(120px, 0.7fr) minmax(150px, 0.9fr) minmax(220px, 1.6fr) minmax(170px, 1.1fr) minmax(170px, 1.1fr) minmax(190px, 1.2fr)";

        const ganttMonthWidth = 36;
        const monthGridStyle = useMemo(
          () => ({ gridTemplateColumns: `repeat(${durationMonths}, ${ganttMonthWidth}px)` }),
          [durationMonths]
        );
        const ganttTrackWidth = durationMonths * ganttMonthWidth;
        const ganttContentWidth = ganttTrackWidth;
        const rightContentWidth = activeCompanyIndexes.length * COMPANY_COLUMN_PX + ganttContentWidth;
        const combinedGridTemplate = `${DESCRIPTION_COLUMN_PX}px ${rightContentWidth}px`;
        const rightGridTemplate = `repeat(${activeCompanyIndexes.length}, ${COMPANY_COLUMN_PX}px) ${ganttContentWidth}px`;
        const ganttMaxScroll = Math.max(0, ganttScrollWidth - ganttViewportWidth);

        useEffect(() => {
          if (!ganttScrollContainerRef.current || typeof ResizeObserver === "undefined") return;
          const target = ganttScrollContainerRef.current;
          const updateSizes = () => {
            setGanttViewportWidth(target.clientWidth || 0);
            setGanttScrollWidth(target.scrollWidth || 0);
          };
          updateSizes();
          const observer = new ResizeObserver(() => {
            updateSizes();
          });
          observer.observe(target);
          return () => observer.disconnect();
        }, []);

        useEffect(() => {
          setGanttScrollLeft((prev) => Math.min(prev, ganttMaxScroll));
        }, [ganttMaxScroll]);

        useEffect(() => {
          if (!ganttScrollContainerRef.current) return;
          ganttScrollContainerRef.current.scrollLeft = ganttScrollLeft;
        }, [ganttScrollLeft]);

        useEffect(() => {
          if (!ganttScrollContainerRef.current) return;
          setGanttViewportWidth(ganttScrollContainerRef.current.clientWidth || 0);
          setGanttScrollWidth(ganttScrollContainerRef.current.scrollWidth || 0);
        }, [durationMonths, companyCount, workPackages.length, ganttContentWidth]);

        const getAssignedCompanyIndex = (pmByCompany = []) => {
          const positiveIndexes = activeCompanyIndexes.filter(
            (companyIndex) => normalizePmValue(pmByCompany?.[companyIndex]) > 0
          );
          return positiveIndexes.length === 1 ? positiveIndexes[0] : null;
        };

        const ganttBarsByRowId = useMemo(() => {
          const projectStart = parseDate(startDate);
          const projectStartIndex = projectStart.getFullYear() * 12 + projectStart.getMonth();
          const bars = {};
          workPackageRows.forEach((row) => {
            if (!row.number.includes(".")) return;
            const assignedCompanyIndex = getAssignedCompanyIndex(row.pmByCompany);
            if (assignedCompanyIndex === null) return;
            const entries = companyData[assignedCompanyIndex]?.tabellenEintraege || {};
            const assignment = entries[row.id] || {};
            const span = getMonthSpan(assignment.start, assignment.ende);
            if (!span || span.totalMonths <= 0) return;
            const parsedStart = parseMonthYear(assignment.start);
            if (!parsedStart) return;
            const startIndex = parsedStart.year * 12 + parsedStart.month - projectStartIndex;
            const endIndex = startIndex + span.totalMonths - 1;
            const clippedStart = Math.max(0, startIndex);
            const clippedEnd = Math.min(durationMonths - 1, endIndex);
            if (clippedEnd < 0 || clippedStart > durationMonths - 1 || clippedEnd < clippedStart) {
              return;
            }
            bars[row.id] = {
              start: clippedStart,
              end: clippedEnd,
              companyIndex: assignedCompanyIndex,
            };
          });
          return bars;
        }, [workPackageRows, companyData, startDate, durationMonths, activeCompanyIndexes]);

        const getRowTone = (row) => {
          if (row.type === "total") return "bg-[var(--ca-green-soft-strong)]";
          if (row.type === "summary") return "bg-[var(--ca-green-soft)]";
          if (row.type === "wp") return "bg-[var(--ca-green-soft)]/70";
          if (row.type === "sub") {
            return row.subIndex % 2 === 0 ? "bg-white" : "bg-[var(--ca-green-soft)]/45";
          }
          return "bg-white";
        };

        const getRowHeight = (row) => {
          if (row.type === "header") return "min-h-[120px]";
          return "min-h-[40px]";
        };

        const autoResizeTextarea = (event) => {
          const textarea = event.target;
          const minHeight = 32;
          textarea.style.height = "auto";
          textarea.style.height = `${Math.max(textarea.scrollHeight, minHeight)}px`;
        };

        useEffect(() => {
          const resizeAll = () => {
            const nodes = document.querySelectorAll("[data-auto-resize='true']");
            nodes.forEach((node) => {
              node.style.height = "auto";
              node.style.height = `${Math.max(node.scrollHeight, 32)}px`;
            });
          };
          requestAnimationFrame(resizeAll);
        }, [workPackages, companyCount]);

        useEffect(() => {
          if (!ganttScrollContainerRef.current || typeof ResizeObserver === "undefined") return;
          const resizeAll = () => {
            const nodes = document.querySelectorAll("[data-auto-resize='true']");
            nodes.forEach((node) => {
              node.style.height = "auto";
              node.style.height = `${Math.max(node.scrollHeight, 32)}px`;
            });
          };
          const observer = new ResizeObserver(() => {
            requestAnimationFrame(resizeAll);
          });
          observer.observe(ganttScrollContainerRef.current);
          return () => observer.disconnect();
        }, [companyCount, durationMonths]);

        const formatCurrency = (value) =>
          new Intl.NumberFormat("de-DE", {
            style: "currency",
            currency: "EUR",
            minimumFractionDigits: 2,
            maximumFractionDigits: 2,
          }).format(value || 0);

        const formatNumberDe = (value, maximumFractionDigits = 2) =>
          new Intl.NumberFormat("de-DE", {
            minimumFractionDigits: 0,
            maximumFractionDigits,
          }).format(value || 0);

        const getCurrencyInputDisplay = (key, value) => {
          if (focusedCurrencyField === key) {
            const numericValue = parseNumber(value);
            return numericValue ? `${numericValue}` : "";
          }
          return parseNumber(value) ? formatNumberDe(parseNumber(value), 2) : "";
        };

        const employeePmByCompany = useMemo(() => {
          return activeCompanyIndexes.reduce((acc, companyIndex) => {
            const companyEmployees = employeesByCompany[companyIndex] || [];
            const usedByYear = companyEmployees.map(() => ({}));
            const totals = companyEmployees.map(() => 0);
            (filteredWorkPackageRowsByCompany[companyIndex] || []).forEach((row) => {
              const pmDemand = normalizePmValue(row.pmByCompany?.[companyIndex]);
              if (!pmDemand) return;
              const entry = companyData[companyIndex]?.tabellenEintraege?.[row.id] || {};
              const employeeNumber = parseInt(entry.mitarbeiterNummer, 10);
              if (!employeeNumber || employeeNumber < 1) return;
              const employeeIndex = employeeNumber - 1;
              if (!usedByYear[employeeIndex]) return;
              const monthSpan = getMonthSpan(entry.start, entry.ende);
              if (!monthSpan || !monthSpan.totalMonths) return;
              const pmPerMonth = pmDemand / monthSpan.totalMonths;
              totals[employeeIndex] += pmDemand;
              Object.entries(monthSpan.monthsByYear).forEach(([year, months]) => {
                usedByYear[employeeIndex][year] =
                  (usedByYear[employeeIndex][year] || 0) + pmPerMonth * months;
              });
            });
            acc[companyIndex] = { byYear: usedByYear, totals };
            return acc;
          }, {});
        }, [
          activeCompanyIndexes,
          employeesByCompany,
          filteredWorkPackageRowsByCompany,
          companyData,
        ]);

        const fundingResultsByCompany = useMemo(() => {
          return activeCompanyIndexes.reduce((acc, companyIndex) => {
            const companyEmployees = employeesByCompany[companyIndex] || [];
            const pmTotals = employeePmByCompany[companyIndex]?.totals || [];
            const pmByYear = employeePmByCompany[companyIndex]?.byYear || [];
            const personalkosten = companyEmployees.reduce((sum, employee, index) => {
              const annualSalary = parseNumber(employee.annualSalary);
              const pmTotal = pmTotals[index] || 0;
              return sum + pmTotal * (annualSalary / 12);
            }, 0);
            const yearlyPersonalkosten = projectYears.reduce((yearAcc, year) => {
              const yearCost = companyEmployees.reduce((sum, employee, employeeIndex) => {
                const annualSalary = parseNumber(employee.annualSalary);
                const pmYear = pmByYear[employeeIndex]?.[year] || 0;
                return sum + pmYear * (annualSalary / 12);
              }, 0);
              yearAcc[year] = yearCost;
              return yearAcc;
            }, {});
            const zuschlagInput = parseNumber(
              companyData[companyIndex]?.zuschlagsfaktorPercent
            );
            const foerderquoteInput = parseNumber(
              companyData[companyIndex]?.foerderquotePercent
            );
            const maximalbetrag = parseNumber(companyData[companyIndex]?.maximalbetrag);
            const projektsummeRoh = personalkosten * (1 + zuschlagInput / 100);
            const projektsummeFinal = Math.min(projektsummeRoh, maximalbetrag);
            const realerZuschlagsfaktor =
              personalkosten > 0
                ? ((projektsummeFinal / personalkosten) - 1) * 100
                : 0;
            const cappedRealerZuschlagsfaktor = Math.min(
              realerZuschlagsfaktor,
              zuschlagInput
            );
            const foerdersumme = projektsummeFinal * (foerderquoteInput / 100);
            const maxMoeglicheFoerdersumme = maximalbetrag * (foerderquoteInput / 100);
            const verschenkt = Math.max(0, maxMoeglicheFoerdersumme - foerdersumme);

            const annualFunding = projectYears.reduce((yearAcc, year) => {
              const ratio = personalkosten > 0 ? (yearlyPersonalkosten[year] || 0) / personalkosten : 0;
              yearAcc[year] = foerdersumme * ratio;
              return yearAcc;
            }, {});
            const annualSum = Object.values(annualFunding).reduce((sum, value) => sum + value, 0);
            if (projectYears.length) {
              const lastYear = projectYears[projectYears.length - 1];
              annualFunding[lastYear] = (annualFunding[lastYear] || 0) + (foerdersumme - annualSum);
            }

            acc[companyIndex] = {
              personalkosten: roundToTwo(personalkosten),
              projektsumme: roundToTwo(projektsummeFinal),
              foerdersumme: roundToTwo(foerdersumme),
              verschenkt: roundToTwo(verschenkt),
              realerZuschlagsfaktor: roundToTwo(cappedRealerZuschlagsfaktor),
              annualFunding,
            };
            return acc;
          }, {});
        }, [activeCompanyIndexes, employeesByCompany, employeePmByCompany, companyData, projectYears]);

        const fullscreenCompanyData = useMemo(() => {
          if (fullscreenCompanyIndex === null || fullscreenCompanyIndex === undefined) return null;
          const companyIndex = fullscreenCompanyIndex;
          const companyName = companyNames[companyIndex] || `Unternehmen ${companyIndex + 1}`;
          const companyEmployees = employeesByCompany[companyIndex] || [];
          const companyCosts = employeeCostsByCompany[companyIndex] || [];
          const companyRows = (filteredWorkPackageRowsByCompany[companyIndex] || [])
            .filter((row) => normalizePmValue(row.pmByCompany?.[companyIndex]) > 0)
            .map((row) => {
              const entry = companyData[companyIndex]?.tabellenEintraege?.[row.id] || {};
              return {
                id: row.id,
                number: row.number,
                title: row.title,
                start: entry.start || "–",
                end: entry.ende || "–",
                employeeNumber: entry.mitarbeiterNummer || "–",
                pm: normalizePmValue(row.pmByCompany?.[companyIndex]),
              };
            })
            .sort((a, b) => {
              const aParsed = parseMonthYear(a.start);
              const bParsed = parseMonthYear(b.start);
              const aIndex = aParsed ? aParsed.year * 12 + aParsed.month : Number.MAX_SAFE_INTEGER;
              const bIndex = bParsed ? bParsed.year * 12 + bParsed.month : Number.MAX_SAFE_INTEGER;
              return aIndex - bIndex;
            });

          const pmByYear = employeePmByCompany[companyIndex]?.byYear || [];
          const personnelByYear = {};
          projectYears.forEach((year) => {
            personnelByYear[year] = companyEmployees.reduce((sum, employee, employeeIndex) => {
              const annualSalary = parseNumber(employee.annualSalary);
              const pm = pmByYear[employeeIndex]?.[year] || 0;
              return sum + pm * (annualSalary / 12);
            }, 0);
          });
          const fundingTotals = fundingResultsByCompany[companyIndex] || {};
          const personnelTotal = projectYears.reduce((sum, year) => sum + (personnelByYear[year] || 0), 0);
          const projectSumTotal = fundingTotals.projektsumme || 0;
          const fundingTotal = fundingTotals.foerdersumme || 0;
          const yearlyFundingRows = projectYears.map((year) => {
            const ratio = personnelTotal > 0 ? (personnelByYear[year] || 0) / personnelTotal : 0;
            return {
              year,
              personalkosten: personnelByYear[year] || 0,
              projektsumme: projectSumTotal * ratio,
              foerderung: fundingTotal * ratio,
            };
          });
          if (yearlyFundingRows.length) {
            const sums = yearlyFundingRows.reduce(
              (acc, row) => {
                acc.personalkosten += row.personalkosten;
                acc.projektsumme += row.projektsumme;
                acc.foerderung += row.foerderung;
                return acc;
              },
              { personalkosten: 0, projektsumme: 0, foerderung: 0 }
            );
            const last = yearlyFundingRows[yearlyFundingRows.length - 1];
            last.personalkosten += (fundingTotals.personalkosten || 0) - sums.personalkosten;
            last.projektsumme += (fundingTotals.projektsumme || 0) - sums.projektsumme;
            last.foerderung += (fundingTotals.foerdersumme || 0) - sums.foerderung;
          }

          return {
            companyIndex,
            companyName,
            color: getCompanyColorHex(companyIndex),
            workPackageRows: companyRows,
            employees: companyEmployees.map((employee, employeeIndex) => {
              const pmTotal = (employeePmByCompany[companyIndex]?.totals || [])[employeeIndex] || 0;
              const costPerPM = companyCosts[employeeIndex]?.costPerPM || 0;
              return {
                number: employee.number || employeeIndex + 1,
                name: employee.name || `Mitarbeiter ${employeeIndex + 1}`,
                years: projectYears.reduce((acc, year) => {
                  const pm = pmByYear[employeeIndex]?.[year] || 0;
                  acc[year] = { pm, cost: pm * costPerPM };
                  return acc;
                }, {}),
                pmTotal,
              };
            }),
            projectYears,
            yearlyFundingRows,
            totals: {
              personalkosten: fundingTotals.personalkosten || 0,
              projektsumme: fundingTotals.projektsumme || 0,
              foerderung: fundingTotals.foerdersumme || 0,
            },
          };
        }, [
          fullscreenCompanyIndex,
          companyNames,
          employeesByCompany,
          employeeCostsByCompany,
          filteredWorkPackageRowsByCompany,
          companyData,
          employeePmByCompany,
          projectYears,
          fundingResultsByCompany,
        ]);


        const closeZimModal = () => {
          setZimPdfModalState((prev) => {
            if (prev.downloadUrl) {
              URL.revokeObjectURL(prev.downloadUrl);
            }
            return {
              open: false,
              companyIndex: null,
              companyName: "",
              fieldNames: [],
              mappings: [],
              unmappedFields: [],
              acronymInPdf: "",
              acronymStatus: "unknown",
              warningAccepted: false,
              analysisMessage: "",
              analysisError: "",
              noFormFields: false,
              uploadedFile: null,
              downloadUrl: "",
              downloadName: "",
            };
          });
        };

        const getCompanyExportContext = (companyIndex) => {
          const companyName = companyNames[companyIndex] || `Unternehmen ${companyIndex + 1}`;
          const fundingResults = fundingResultsByCompany[companyIndex] || {};
          const companyRows = filteredWorkPackageRowsByCompany[companyIndex] || [];
          const tabellenEintraege = companyData[companyIndex]?.tabellenEintraege || {};
          const companyEmployees = employeesByCompany[companyIndex] || [];
          const projectStartDate = parseDate(startDate);
          const projectEndDate = new Date(projectStartDate.getFullYear(), projectStartDate.getMonth() + durationMonths - 1, 1);
          const yearlyFundingSums = Object.entries(fundingResults.annualFunding || {}).reduce((acc, [year, value]) => {
            acc[year] = roundToTwo(value || 0);
            return acc;
          }, {});
          return {
            projectName: currentProjectName,
            companyName,
            payload: {
              project: {
                name: currentProjectName,
                startDate,
                durationMonths,
                endDate: toIsoDate(projectEndDate),
              },
              company: {
                id: companyIndex,
                name: companyName,
                funding: {
                  ratePct: roundToTwo(companyData[companyIndex]?.foerderquotePercent || 0),
                  surchargePct: roundToTwo(companyData[companyIndex]?.zuschlagsfaktorPercent || 0),
                  maxProjectSum: roundToTwo(companyData[companyIndex]?.maximalbetrag || 0),
                },
                computed: {
                  personnelCost: roundToTwo(fundingResults.personalkosten || 0),
                  projectSum: roundToTwo(fundingResults.projektsumme || 0),
                  fundingSum: roundToTwo(fundingResults.foerdersumme || 0),
                  verschenkt: roundToTwo(fundingResults.verschenkt || 0),
                  realSurchargePct: roundToTwo(fundingResults.realerZuschlagsfaktor || 0),
                },
                yearlyFundingSums,
              },
              workPackages: companyRows.map((row) => {
                const pm = normalizePmValue(row.pmByCompany?.[companyIndex]);
                if (pm <= 0) return null;
                return {
                  nr: row.number,
                  title: row.title,
                  pm,
                  startMonth: tabellenEintraege[row.id]?.start || "",
                  endMonth: tabellenEintraege[row.id]?.ende || "",
                  employeeNo: tabellenEintraege[row.id]?.mitarbeiterNummer || "",
                };
              }).filter(Boolean),
              employees: companyEmployees.map((employee, index) => ({
                no: `${index + 1}`,
                name: employee.name || "",
                annualSalary: parseNumber(employee.annualSalary),
              })),
            },
          };
        };

        const analyzeZimPdf = async () => {
          if (!zimPdfModalState.uploadedFile || zimPdfModalState.companyIndex === null) return;
          const context = getCompanyExportContext(zimPdfModalState.companyIndex);
          const formData = new FormData();
          formData.append("file", zimPdfModalState.uploadedFile);
          formData.append("payload", JSON.stringify(context.payload));
          try {
            setZimPdfModalState((prev) => ({ ...prev, analysisError: "", analysisMessage: "Analysiere PDF-Felder..." }));
            const response = await fetch("/api/zim/analyze", { method: "POST", body: formData });
            const data = await response.json();
            if (!response.ok) throw new Error(data?.detail || data?.error || "PDF konnte nicht analysiert werden.");
            setZimPdfModalState((prev) => ({
              ...prev,
              companyName: context.companyName,
              fieldNames: data.fields || [],
              mappings: (data.mappingPreview || []).filter((entry) => entry.status === "willFill"),
              unmappedFields: (data.mappingPreview || []).filter((entry) => entry.status !== "willFill").map((entry) => entry.path),
              acronymInPdf: data.pdfAcronym || "",
              acronymStatus: data.acronymMismatch ? "mismatch" : data.pdfAcronym ? "match" : "missing",
              warningAccepted: false,
              analysisMessage: "PDF-Felder wurden analysiert.",
              analysisError: "",
              noFormFields: !(data.fields || []).length,
              downloadUrl: "",
              downloadName: "",
            }));
          } catch (error) {
            setZimPdfModalState((prev) => ({
              ...prev,
              analysisError: error.message || "PDF konnte nicht analysiert werden.",
              analysisMessage: "",
              fieldNames: [],
              mappings: [],
              unmappedFields: [],
              noFormFields: false,
            }));
          }
        };

        const exportZimPdf = async () => {
          if (!zimPdfModalState.uploadedFile || zimPdfModalState.companyIndex === null) return;
          try {
            const context = getCompanyExportContext(zimPdfModalState.companyIndex);
            const formData = new FormData();
            formData.append("file", zimPdfModalState.uploadedFile);
            formData.append("payload", JSON.stringify(context.payload));
            formData.append("confirmMismatch", zimPdfModalState.warningAccepted ? "true" : "false");
            const response = await fetch("/api/zim/fill", { method: "POST", body: formData });
            if (!response.ok) {
              const data = await response.json();
              if (response.status === 409) {
                setZimPdfModalState((prev) => ({
                  ...prev,
                  acronymInPdf: data.pdfAcronym || prev.acronymInPdf,
                  acronymStatus: "mismatch",
                  analysisError: "Akronym in PDF weicht vom Projektnamen ab. Bitte bestätigen.",
                }));
                return;
              }
              throw new Error(data?.detail || data?.error || "PDF konnte nicht ausgefüllt werden.");
            }

            const blob = await response.blob();
            const contentDisposition = response.headers.get("Content-Disposition") || "";
            const filenameMatch = contentDisposition.match(/filename="([^"]+)"/i);
            const downloadName = filenameMatch?.[1] || `${context.projectName}_${context.companyName}_Mantelbogen.pdf`;
            setZimPdfModalState((prev) => {
              if (prev.downloadUrl) URL.revokeObjectURL(prev.downloadUrl);
              return {
                ...prev,
                analysisError: "",
                downloadUrl: URL.createObjectURL(blob),
                downloadName,
              };
            });
          } catch (error) {
            setZimPdfModalState((prev) => ({
              ...prev,
              analysisError: error.message || "PDF konnte nicht ausgefüllt werden.",
            }));
          }
        };

        return (
          <div className="min-h-screen bg-slate-50 text-slate-900" onBlurCapture={saveNow}>
            <header className="ca-topbar border-b border-black/10 shadow-subtle">
              <div className="mx-auto flex h-[96px] max-w-[1700px] items-center justify-between px-6">
                <div className="flex items-center gap-4">
                  <img
                    src="/campusalliance-logo.svg"
                    alt="CampusAlliance"
                    className="h-14 w-auto"
                  />
                  <div className="text-xl font-semibold tracking-wide text-white">
                    CampusAlliance Projektplanung
                  </div>
                </div>
                <div className="flex items-center gap-3">
                  <div className="rounded-md border border-white/30 bg-white/10 px-4 py-2 text-base font-semibold text-white">
                    Projekt: {currentProjectName || "–"}
                  </div>
                  <button
                    type="button"
                    onClick={() => {
                      setNewProjectModalOpen(true);
                      setProjectError("");
                    }}
                    className="rounded-md border border-white/40 bg-white/15 px-3 py-2 text-sm font-semibold text-white transition hover:bg-white/25"
                  >
                    Neues Projekt
                  </button>
                  <button
                    type="button"
                    onClick={() => {
                      setLoadProjectModalOpen(true);
                      setProjectSearchTerm("");
                    }}
                    className="rounded-md border border-white/40 bg-white/15 px-3 py-2 text-sm font-semibold text-white transition hover:bg-white/25"
                  >
                    Projekt laden
                  </button>
                  <div className="text-xs text-white/90">{saveState === "speichert..." ? "Speichern..." : "Gespeichert"}</div>
                </div>
              </div>
            </header>

            <main className="mx-auto max-w-[1700px] px-6 py-8">
              {storageError ? (
                <div className="mb-4 rounded-md border border-red-200 bg-red-50 px-4 py-3 text-sm text-red-700">
                  {storageError}
                </div>
              ) : null}
              <div className="mb-6 grid gap-4 lg:grid-cols-[2.2fr_1.2fr_1fr]">
                <div className="rounded-lg border border-slate-200 bg-white px-4 py-3 shadow-subtle">
                  <div className="flex flex-wrap items-start justify-between gap-4">
                    <div>
                      <div className="text-xs font-semibold uppercase text-slate-500">
                        Unternehmen
                      </div>
                      <label className="mt-3 flex items-center gap-3 text-sm font-medium text-slate-700">
                        Anzahl Unternehmen
                        <input
                          type="number"
                          min="1"
                          max="5"
                          value={companyCount}
                          onChange={(event) =>
                            setCompanyCount(
                              clampNumber(parseInt(event.target.value || "1", 10), 1, 5)
                            )
                          }
                          className="h-9 w-20 rounded-md border border-slate-300 px-2 text-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
                        />
                      </label>
                    </div>
                    <div className="min-w-[240px] flex-1">
                      <div className="text-xs font-semibold uppercase text-slate-500">
                        Unternehmensnamen
                      </div>
                      <div className="mt-3 grid gap-2 sm:grid-cols-2">
                        {activeCompanyIndexes.map((idx) => {
                          const companyColor = getCompanyColorPalette(idx);
                          return (
                            <input
                              key={`company-name-${idx}`}
                              type="text"
                              value={companyNames[idx] || `Unternehmen ${idx + 1}`}
                              onChange={(event) =>
                                setCompanyNames((prev) => {
                                  const next = [...prev];
                                  next[idx] = event.target.value;
                                  return next;
                                })
                              }
                              className="w-full rounded-md border-2 px-3 py-2 text-sm focus:outline-none focus:ring-2"
                              style={{ borderColor: companyColor?.base, boxShadow: `0 0 0 0 ${companyColor?.inputFocus}` }}
                              onFocus={(event) => {
                                event.currentTarget.style.boxShadow = `0 0 0 3px ${companyColor?.inputFocus}`;
                              }}
                              onBlur={(event) => {
                                event.currentTarget.style.boxShadow = `0 0 0 0 ${companyColor?.inputFocus}`;
                              }}
                            />
                          );
                        })}
                      </div>
                    </div>
                  </div>

                  <div className="mt-4 flex flex-wrap items-center gap-3">
                    <button
                      type="button"
                      onClick={addWp}
                      disabled={workPackages.length >= MAX_WP}
                      className="inline-flex items-center gap-2 rounded-md bg-slate-900 px-4 py-2 text-sm font-semibold text-white shadow-subtle transition disabled:cursor-not-allowed disabled:bg-slate-300"
                    >
                      + Arbeitspaket
                    </button>
                    <button
                      type="button"
                      onClick={() => requestDelete("wp", workPackages.length - 1)}
                      disabled={workPackages.length === 0}
                      className="inline-flex items-center gap-2 rounded-md border border-slate-300 bg-white px-4 py-2 text-sm font-semibold text-slate-700 shadow-subtle transition hover:border-slate-400 disabled:cursor-not-allowed disabled:border-slate-200 disabled:text-slate-300"
                    >
                      – Arbeitspaket
                    </button>
                    {pendingDelete?.type === "wp" && (
                      <span className="inline-flex items-center gap-2 text-xs text-rose-600">
                        Wirklich löschen?
                        <button
                          type="button"
                          onClick={confirmDelete}
                          className="rounded border border-rose-200 px-2 py-1 text-rose-700"
                        >
                          Ja
                        </button>
                        <button
                          type="button"
                          onClick={cancelDelete}
                          className="rounded border border-slate-200 px-2 py-1 text-slate-600"
                        >
                          Nein
                        </button>
                      </span>
                    )}
                  </div>
                </div>

                <div className="rounded-lg border border-slate-200 bg-white px-4 py-3 shadow-subtle">
                  <div className="text-xs font-semibold uppercase text-slate-500">
                    Projektstart
                  </div>
                  <input
                    type="date"
                    value={startDate}
                    onChange={(event) => {
                      setStartDate(event.target.value);
                    }}
                    className="mt-2 w-full rounded-md border border-slate-300 px-3 py-2 text-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
                  />
                </div>

                <div className="rounded-lg border border-slate-200 bg-white px-4 py-3 shadow-subtle">
                  <div className="text-xs font-semibold uppercase text-slate-500">
                    Laufzeit (Monate)
                  </div>
                  <input
                    type="number"
                    min="1"
                    max={MAX_DURATION}
                    value={durationMonths}
                    onChange={(event) =>
                      {
                        setDurationMonths(
                          clampNumber(
                            parseInt(event.target.value || "1", 10),
                            1,
                            MAX_DURATION
                          )
                        );
                      }
                    }
                    className="mt-2 w-full rounded-md border border-slate-300 px-3 py-2 text-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
                  />
                </div>
              </div>

              <div className="mb-3 flex flex-wrap items-end justify-between gap-3">
                <div>
                  <p className="text-xs font-semibold uppercase tracking-[0.18em] text-slate-500">
                    Projektplanung
                  </p>
                  <h2 className="text-xl font-semibold text-slate-850">
                    Projektplanung gesamt
                  </h2>
                </div>
              </div>

              <div className="rounded-xl border border-[var(--ca-green-border)] bg-white shadow-subtle">
                <div ref={ganttScrollContainerRef} onScroll={handleGanttScroll} className="overflow-x-auto">
                  <div style={{ minWidth: `${DESCRIPTION_COLUMN_PX + rightContentWidth}px` }}>
                    <div className="sticky top-0 z-30 border-b border-[var(--ca-green-border)]" style={{ backgroundColor: "var(--ca-green-soft)" }}>
                      <div
                        className={`grid items-stretch ${getRowHeight({ type: "header" })}`}
                        style={{ gridTemplateColumns: combinedGridTemplate }}
                      >
                        <div className="sticky left-0 z-40 border-r border-[var(--ca-green-border)] px-4 py-4 text-sm font-semibold text-slate-700" style={{ backgroundColor: "var(--ca-green-soft)" }}>Arbeitspaketnummer + Beschreibung</div>
                        <div className="grid" style={{ gridTemplateColumns: rightGridTemplate, minWidth: `${rightContentWidth}px` }}>
                          {activeCompanyIndexes.map((idx) => (
                            <div key={`header-company-${idx}`} className="px-2 py-4 text-xs font-semibold uppercase text-slate-600">
                              <span className="block whitespace-normal break-words leading-tight" title={companyNames[idx] || `Unternehmen ${idx + 1}`}>
                                {companyNames[idx] || `Unternehmen ${idx + 1}`}
                              </span>
                            </div>
                          ))}
                          <div className="px-4 py-3 border-l border-[var(--ca-green-border)]" style={{ backgroundColor: "var(--ca-green-soft-strong)" }}>
                            <div className={`flex h-full flex-col ${getRowHeight({ type: "header" })}`}>
                              <div className="mb-2 flex items-center justify-between text-sm font-semibold text-slate-700">
                                <span>Gantt-Zeitleiste (alle Unternehmen)</span>
                                <span className="text-xs font-medium text-slate-500">Monate 1–{durationMonths}</span>
                              </div>
                              <div className="mt-1 flex items-center gap-3">
                                <input type="range" min="0" max={ganttMaxScroll} value={ganttScrollLeft} onChange={handleGanttSliderChange} className="h-2 w-full" style={{ accentColor: "var(--ca-green)" }} />
                                <span className="text-[11px] font-medium text-slate-500">Scroll</span>
                              </div>
                              <div className="mt-2 rounded-md border border-[var(--ca-green-border)]" style={{ minWidth: `${ganttContentWidth}px`, backgroundColor: "var(--ca-green-soft)" }}>
                                <div className="grid text-center text-[11px] font-semibold uppercase text-slate-600" style={{ ...monthGridStyle, minWidth: `${ganttContentWidth}px`, backgroundColor: "var(--ca-green-soft)" }}>
                                  {yearSegments.map((segment, index) => (
                                    <div key={`year-${segment.year}-${index}`} className="border-r border-[var(--ca-green-border)] py-1" style={{ gridColumn: `span ${segment.span}` }}>
                                      {segment.year}
                                    </div>
                                  ))}
                                </div>
                                <div className="gantt-grid border-t border-[var(--ca-green-border)] text-[10px] text-slate-500" style={{ ...monthGridStyle, minWidth: `${ganttContentWidth}px` }}>
                                  {timeline.map((month, index) => (
                                    <div key={`month-${month.year}-${index}`} className="border-r border-[var(--ca-green-border)] py-1 text-center">{month.label}</div>
                                  ))}
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>

                    <div>
                      {rows.map((row, rowIndex) => {
                        const wpIndex = row.wpIndex;
                        const rowDataForColor =
                          row.type === "wp"
                            ? workPackages[wpIndex]
                            : row.type === "sub"
                              ? workPackages[wpIndex]?.sub[row.subIndex]
                              : null;
                        const assignedCompanyIndex = rowDataForColor
                          ? getAssignedCompanyIndex(rowDataForColor.pm)
                          : null;
                        const companyColor =
                          assignedCompanyIndex !== null
                            ? getCompanyColorPalette(assignedCompanyIndex)
                            : null;
                        const isGroupStart = row.type === "wp";
                        const groupBorder = isGroupStart ? "border-t border-[var(--ca-green-border)]" : "border-t border-[var(--ca-green-border)]/70";

                        let descriptionCell = null;
                        let pmCells = null;
                        let bar = null;

                        if (row.type === "summary") {
                          descriptionCell = <div className="px-4 py-2 text-sm font-semibold text-slate-700">Σ PM je Unternehmen</div>;
                          pmCells = activeCompanyIndexes.map((idx, localIdx) => (
                            <div key={`summary-${idx}`} className="px-2 py-2 text-sm font-semibold text-slate-700">{formatNumberDe(sumByCompany(workPackages[row.wpIndex])[localIdx])}</div>
                          ));
                        } else if (row.type === "total") {
                          descriptionCell = <div className="px-4 py-3 text-sm font-bold text-slate-800">Gesamtsumme PM</div>;
                          pmCells = activeCompanyIndexes.map((idx, localIdx) => (
                            <div key={`total-${idx}`} className="px-2 py-3 text-sm font-bold text-slate-800">{formatNumberDe(totalByCompany[localIdx])}</div>
                          ));
                        } else {
                          const subIndex = row.subIndex;
                          const isWp = row.type === "wp";
                          const wpNumber = wpIndex + 1;
                          const subNumber = subIndex !== null ? `${wpNumber}.${subIndex + 1}` : "";
                          const title = subIndex === null ? workPackages[wpIndex].title : workPackages[wpIndex].sub[subIndex].title;
                          const values = subIndex === null ? workPackages[wpIndex].pm : workPackages[wpIndex].sub[subIndex].pm;
                          const isPending = pendingDelete?.wpIndex === wpIndex && pendingDelete?.type === "sub" && pendingDelete?.subIndex === workPackages[wpIndex].sub.length - 1;
                          const rowData = subIndex === null ? workPackages[wpIndex] : workPackages[wpIndex].sub[subIndex];
                          const ganttBar = ganttBarsByRowId[rowData.id];
                          if (ganttBar) {
                            bar = (
                              <div
                                className="absolute top-1/2 h-5 -translate-y-1/2 rounded-md"
                                style={{
                                  left: `${ganttBar.start * ganttMonthWidth + 2}px`,
                                  width: `${(ganttBar.end - ganttBar.start + 1) * ganttMonthWidth - 4}px`,
                                  backgroundColor: getCompanyColorPalette(ganttBar.companyIndex)?.bar,
                                  border: `1px solid ${getCompanyColorPalette(ganttBar.companyIndex)?.barBorder}`,
                                }}
                              />
                            );
                          }

                          descriptionCell = (
                            <div className="px-4 py-2 border-l-4" style={{ borderLeftColor: companyColor?.strip || "transparent" }}>
                              <div className={`flex gap-3 ${isWp ? "" : "pl-4"}`}>
                                <div className="pt-1">
                                  <span className={`inline-flex min-w-[36px] items-center justify-center rounded-full px-2 py-1 font-mono text-xs font-semibold ${isWp ? "bg-slate-900/10 text-slate-700" : "bg-slate-500/10 text-slate-500"}`}>{isWp ? wpNumber : subNumber}</span>
                                </div>
                                <div className="flex-1">
                                  <textarea
                                    value={title}
                                    onChange={(event) => isWp ? updateWpTitle(wpIndex, event.target.value) : updateSubTitle(wpIndex, subIndex, event.target.value)}
                                    onInput={autoResizeTextarea}
                                    placeholder={isWp ? "Arbeitspaket beschreiben..." : "Unterarbeitspaket hinzufügen..."}
                                    rows={1}
                                    data-auto-resize="true"
                                    className={`w-full resize-none rounded-md border border-slate-300 px-3 py-2 text-sm leading-snug focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500 ${isWp ? "font-semibold" : "font-normal"} min-h-[32px] h-auto overflow-hidden text-justify`}
                                  />
                                  <div className="mt-1 flex flex-wrap items-center gap-2 text-xs text-slate-500">
                                    {isWp && (
                                      <>
                                        <button type="button" onClick={() => addSub(wpIndex)} disabled={workPackages[wpIndex].sub.length >= MAX_SUB} className="rounded border border-slate-200 px-2 py-1 text-slate-600 transition hover:border-slate-300 hover:text-slate-900 disabled:cursor-not-allowed disabled:text-slate-300">+</button>
                                        <button type="button" onClick={() => requestDelete("sub", wpIndex, workPackages[wpIndex].sub.length - 1)} disabled={workPackages[wpIndex].sub.length === 0} className="rounded border border-slate-200 px-2 py-1 text-slate-600 transition hover:border-slate-300 hover:text-rose-600 disabled:cursor-not-allowed disabled:text-slate-300">–</button>
                                      </>
                                    )}
                                    {isWp && isPending && (
                                      <span className="ml-1 inline-flex items-center gap-1 text-xs text-rose-600">
                                        Letztes Unterarbeitspaket löschen?
                                        <button type="button" onClick={confirmDelete} className="rounded border border-rose-200 px-2 py-1 text-rose-700">Ja</button>
                                        <button type="button" onClick={cancelDelete} className="rounded border border-slate-200 px-2 py-1 text-slate-600">Nein</button>
                                      </span>
                                    )}
                                  </div>
                                </div>
                              </div>
                            </div>
                          );

                          pmCells = activeCompanyIndexes.map((idx) => (
                            <div key={`pm-${row.type}-${wpIndex}-${subIndex ?? "root"}-${idx}`} className="px-2 py-2">
                              {isWp ? (
                                <div className="h-9 flex items-center justify-center text-xs text-slate-400">–</div>
                              ) : (
                                <input type="number" min="0" step="0.1" value={values[idx]} onChange={(event) => updatePm(wpIndex, subIndex, idx, event.target.value)} className="h-9 min-w-[60px] w-full rounded-md border border-slate-300 px-2 text-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500 disabled:bg-slate-100" />
                              )}
                            </div>
                          ));
                        }

                        return (
                          <div
                            key={`combined-row-${row.type}-${rowIndex}`}
                            className={`grid items-stretch ${groupBorder} ${getRowHeight(row)} transition-colors hover:bg-[var(--ca-green-soft)]/70`}
                            style={{ gridTemplateColumns: combinedGridTemplate, minWidth: `${DESCRIPTION_COLUMN_PX + rightContentWidth}px` }}
                          >
                            <div className={`sticky left-0 z-20 border-r border-[var(--ca-green-border)] ${getRowTone(row)}`}>
                              {descriptionCell}
                            </div>
                            <div className={`grid ${getRowTone(row)}`} style={{ gridTemplateColumns: rightGridTemplate, minWidth: `${rightContentWidth}px` }}>
                              {pmCells}
                              <div className="px-4 py-2 border-l border-[var(--ca-green-border)]">
                                <div className="relative rounded border border-[var(--ca-green-border)]" style={{ minWidth: `${ganttContentWidth}px`, backgroundColor: "inherit" }}>
                                  <div className="relative" style={{ minWidth: `${ganttContentWidth}px` }}>
                                    <div className="gantt-grid" style={{ ...monthGridStyle, minWidth: `${ganttContentWidth}px` }}>
                                      {Array.from({ length: durationMonths }, (_, index) => (
                                        <div key={`cell-${row.type}-${rowIndex}-${index}`} className="h-7 border-r border-dashed border-[var(--ca-green-border)]" />
                                      ))}
                                    </div>
                                    {bar}
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </div>
              </div>

              <div className="mt-10 space-y-8">
                {activeCompanyIndexes.map((companyIndex) => {
                  const companyName =
                    companyNames[companyIndex] || `Unternehmen ${companyIndex + 1}`;
                  const companyEmployees = employeesByCompany[companyIndex] || [];
                  const companyCosts = employeeCostsByCompany[companyIndex] || [];
                  const companyRows = filteredWorkPackageRowsByCompany[companyIndex] || [];
                  const displayCompanyRows = companyRows.length
                    ? companyRows
                    : [
                        {
                          id: `placeholder-${companyIndex}`,
                          number: "–",
                          title: "",
                          pmByCompany: [],
                          isPlaceholder: true,
                        },
                      ];
                  const usedPmByEmployee = employeePmByCompany[companyIndex]?.byYear || [];
                  const totalPmByEmployee = employeePmByCompany[companyIndex]?.totals || [];
                  const fundingResults = fundingResultsByCompany[companyIndex] || {
                    personalkosten: 0,
                    projektsumme: 0,
                    foerdersumme: 0,
                    verschenkt: 0,
                    realerZuschlagsfaktor: 0,
                    annualFunding: {},
                  };
                  const utilizationGridColumns = `140px repeat(${projectYears.length}, minmax(120px, 1fr) minmax(150px, 1fr)) minmax(140px, 1fr)`;
                  const companyHistory =
                    companyHistoryByCompany[companyIndex] || createHistoryState({});
                  const autoPlanningLocks = getAutoPlanningLocks(companyIndex);
                  const canUndo = companyHistory.historyIndex > 0;
                  const canRedo = companyHistory.historyIndex < companyHistory.history.length - 1;
                  return (
                    <section
                      key={`company-planning-${companyIndex}`}
                      className="rounded-2xl p-5 shadow-subtle"
                      style={{
                        backgroundColor: getCompanyColorHex(companyIndex),
                        border: `2px solid ${getCompanyColorHex(companyIndex)}`,
                      }}
                    >
                      <div className="rounded-xl border border-slate-200 bg-white px-5 py-4">
                        <p className="text-xs font-semibold uppercase tracking-[0.18em] text-slate-500">
                          Unternehmensplanung
                        </p>
                        <h3 className="mt-2 text-xl font-semibold text-slate-850">
                          Unternehmensplanung: {companyName}
                        </h3>
                        <div className="mt-4 flex flex-wrap gap-2">
                          <button
                            type="button"
                            onClick={() => setFullscreenCompanyIndex(companyIndex)}
                            className="rounded-md border border-slate-300 bg-white px-4 py-2 text-sm font-semibold text-slate-700 hover:bg-slate-100"
                          >
                            Projektplanung in einem separaten Fenster anzeigen
                          </button>
                          <button
                            type="button"
                            onClick={() =>
                              setZimPdfModalState((prev) => ({
                                ...prev,
                                open: true,
                                companyIndex,
                                companyName,
                                fieldNames: [],
                                mappings: [],
                                unmappedFields: [],
                                acronymInPdf: "",
                                acronymStatus: "unknown",
                                warningAccepted: false,
                                analysisMessage: "",
                                analysisError: "",
                                noFormFields: false,
                                uploadedFile: null,
                                downloadUrl: "",
                                downloadName: "",
                              }))
                            }
                            className="rounded-md bg-slate-900 px-4 py-2 text-sm font-semibold text-white hover:bg-slate-800"
                          >
                            Projektplanung in ZIM-Fördermittelantrag übertragen
                          </button>
                        </div>
                      </div>

                      <div className="mt-6 space-y-6">
                        <div className="rounded-xl border border-slate-200 bg-white px-5 py-4">
                          <div className="flex flex-wrap items-center gap-2">
                            <button
                              type="button"
                              onClick={() => runAutoProjectPlanning(companyIndex)}
                              className="h-10 rounded-md bg-slate-900 px-4 text-sm font-semibold text-white hover:bg-slate-800"
                            >
                              Auto Projektplanung
                            </button>
                            <button
                              type="button"
                              aria-label="Undo"
                              title="Undo"
                              onClick={() => undoCompanyAssignment(companyIndex)}
                              disabled={!canUndo}
                              className="inline-flex h-10 w-10 items-center justify-center rounded-md border border-slate-300 bg-white text-xl font-semibold leading-none text-slate-700 hover:bg-slate-100 disabled:cursor-not-allowed disabled:opacity-50"
                            >
                              ↶
                            </button>
                            <button
                              type="button"
                              aria-label="Redo"
                              title="Redo"
                              onClick={() => redoCompanyAssignment(companyIndex)}
                              disabled={!canRedo}
                              className="inline-flex h-10 w-10 items-center justify-center rounded-md border border-slate-300 bg-white text-xl font-semibold leading-none text-slate-700 hover:bg-slate-100 disabled:cursor-not-allowed disabled:opacity-50"
                            >
                              ↷
                            </button>
                          </div>
                          <div className="mt-4 rounded-md border border-slate-200 bg-slate-50 px-4 py-3">
                            <p className="mt-1 text-xs text-slate-600">
                              Diese Einstellungen bleiben bei der Auto-Projektplanung gesperrt.
                            </p>
                            <div className="mt-3 space-y-2">
                              <label className="flex items-start gap-2 text-sm text-slate-700">
                                <input
                                  type="checkbox"
                                  checked={autoPlanningLocks.employeeAssignment}
                                  onChange={(event) =>
                                    updateCompanyField(companyIndex, "autoPlanningLocks", {
                                      ...autoPlanningLocks,
                                      employeeAssignment: event.target.checked,
                                    })
                                  }
                                  className="mt-1"
                                />
                                <span>Zuordnung von Mitarbeitenden zu Arbeitspaketen</span>
                              </label>
                              <label className="flex items-start gap-2 text-sm text-slate-700">
                                <input
                                  type="checkbox"
                                  checked={autoPlanningLocks.workPackageDates}
                                  onChange={(event) =>
                                    updateCompanyField(companyIndex, "autoPlanningLocks", {
                                      ...autoPlanningLocks,
                                      workPackageDates: event.target.checked,
                                    })
                                  }
                                  className="mt-1"
                                />
                                <span>Start- und Enddatum der Arbeitspakete</span>
                              </label>
                              <label className="flex items-start gap-2 text-sm text-slate-700">
                                <input
                                  type="checkbox"
                                  checked={autoPlanningLocks.personMonths}
                                  onChange={(event) =>
                                    updateCompanyField(companyIndex, "autoPlanningLocks", {
                                      ...autoPlanningLocks,
                                      personMonths: event.target.checked,
                                    })
                                  }
                                  className="mt-1"
                                />
                                <span>Absolute Anzahl an Personenmonaten</span>
                              </label>
                            </div>
                          </div>
                        </div>

                        <div className="rounded-xl border border-slate-200 bg-white shadow-subtle">
                          <div className="flex flex-wrap items-start justify-between gap-4 border-b border-slate-200 bg-slate-50 px-5 py-4">
                            <div>
                              <h4 className="text-lg font-semibold text-slate-850">
                                Mitarbeiter
                              </h4>
                              <p className="mt-1 text-sm text-slate-600">
                                Mitarbeitende für {companyName} (max. {MAX_EMPLOYEES}).
                              </p>
                            </div>
                            <div className="flex flex-wrap items-center gap-2">
                              <button
                                type="button"
                                onClick={() => addEmployee(companyIndex)}
                                disabled={companyEmployees.length >= MAX_EMPLOYEES}
                                className="inline-flex items-center gap-2 rounded-md bg-slate-900 px-4 py-2 text-sm font-semibold text-white shadow-subtle transition disabled:cursor-not-allowed disabled:bg-slate-300"
                              >
                                + Mitarbeiter
                              </button>
                              <button
                                type="button"
                                onClick={() => requestEmployeeRemove(companyIndex)}
                                disabled={companyEmployees.length === 0}
                                className="inline-flex items-center gap-2 rounded-md border border-slate-300 bg-white px-4 py-2 text-sm font-semibold text-slate-700 shadow-subtle transition hover:border-slate-400 disabled:cursor-not-allowed disabled:border-slate-200 disabled:text-slate-300"
                              >
                                – Mitarbeiter
                              </button>
                            </div>
                          </div>
                          {pendingEmployeeDelete === companyIndex && (
                            <div className="flex flex-wrap items-center justify-end gap-2 border-b border-slate-200 px-5 py-2 text-xs text-rose-600">
                              Letzten Mitarbeiter wirklich löschen?
                              <button
                                type="button"
                                onClick={confirmEmployeeRemove}
                                className="rounded border border-rose-200 px-2 py-1 text-rose-700"
                              >
                                Ja
                              </button>
                              <button
                                type="button"
                                onClick={cancelEmployeeRemove}
                                className="rounded border border-slate-200 px-2 py-1 text-slate-600"
                              >
                                Nein
                              </button>
                            </div>
                          )}

                          <div className="max-h-[360px] overflow-y-auto">
                            <div className="sticky top-0 z-10 border-b border-slate-200 bg-slate-100/90 backdrop-blur">
                              <div
                                className="grid items-center text-xs font-semibold uppercase text-slate-500"
                                style={{ gridTemplateColumns: employeeGridTemplate }}
                              >
                                <div className="px-4 py-3">Teilzeitfaktor</div>
                                <div className="px-4 py-3">Projekteinsatz %</div>
                                <div className="px-4 py-3">Name</div>
                                <div className="px-4 py-3">Typische Wochenstunden</div>
                                <div className="px-4 py-3">
                                  Tatsächliche Wochenstunden
                                </div>
                                <div className="px-4 py-3">Jahresgehalt</div>
                              </div>
                            </div>

                            <div className="divide-y divide-slate-100">
                              {companyEmployees.map((employee, index) => (
                                <div
                                  key={`company-${companyIndex}-employee-${index}`}
                                  className={`grid items-center h-[56px] bg-white ${
                                    index % 2 === 0 ? "" : "bg-slate-50/60"
                                  }`}
                                  style={{ gridTemplateColumns: employeeGridTemplate }}
                                >
                                  <div className="px-4">
                                    <input
                                      type="number"
                                      min="0"
                                      max="1"
                                      step="0.1"
                                      value={employee.partTimeFactor}
                                      onChange={(event) =>
                                        updateEmployeeNumber(
                                          companyIndex,
                                          index,
                                          "partTimeFactor",
                                          event.target.value,
                                          0,
                                          1
                                        )
                                      }
                                      className="h-9 w-full rounded-md border border-slate-300 px-2 text-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
                                    />
                                  </div>
                                  <div className="px-4">
                                    <input
                                      type="number"
                                      min="0"
                                      max="100"
                                      step="0.1"
                                      value={employee.projectPercent}
                                      onChange={(event) =>
                                        updateEmployeeNumber(
                                          companyIndex,
                                          index,
                                          "projectPercent",
                                          event.target.value,
                                          0,
                                          100
                                        )
                                      }
                                      className="h-9 w-full rounded-md border border-slate-300 px-2 text-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
                                    />
                                  </div>
                                  <div className="px-4">
                                    <input
                                      type="text"
                                      value={employee.name}
                                      onChange={(event) =>
                                        updateEmployeeField(
                                          companyIndex,
                                          index,
                                          "name",
                                          event.target.value
                                        )
                                      }
                                      placeholder={`Mitarbeiter ${index + 1}`}
                                      className="h-9 w-full rounded-md border border-slate-300 px-3 text-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
                                    />
                                  </div>
                                  <div className="px-4">
                                    <input
                                      type="number"
                                      min="0"
                                      step="0.5"
                                      value={employee.weeklyHours}
                                      onChange={(event) =>
                                        updateEmployeeNumber(
                                          companyIndex,
                                          index,
                                          "weeklyHours",
                                          event.target.value,
                                          0
                                        )
                                      }
                                      className="h-9 w-full rounded-md border border-slate-300 px-2 text-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
                                    />
                                  </div>
                                  <div className="px-4">
                                    <input
                                      type="number"
                                      min="0"
                                      step="0.5"
                                      value={employee.actualHours}
                                      onChange={(event) =>
                                        updateEmployeeNumber(
                                          companyIndex,
                                          index,
                                          "actualHours",
                                          event.target.value,
                                          0
                                        )
                                      }
                                      className="h-9 w-full rounded-md border border-slate-300 px-2 text-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
                                    />
                                  </div>
                                  <div className="px-4">
                                    <div className="relative">
                                      <input
                                        type="text"
                                        inputMode="decimal"
                                        value={getCurrencyInputDisplay(`salary-${companyIndex}-${index}`, employee.annualSalary)}
                                        onFocus={() => setFocusedCurrencyField(`salary-${companyIndex}-${index}`)}
                                        onBlur={() => setFocusedCurrencyField(null)}
                                        onChange={(event) =>
                                          updateEmployeeNumber(
                                            companyIndex,
                                            index,
                                            "annualSalary",
                                            event.target.value,
                                            0
                                          )
                                        }
                                        className="h-9 w-full rounded-md border border-slate-300 px-2 pr-7 text-sm focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
                                      />
                                      <span className="pointer-events-none absolute inset-y-0 right-2 flex items-center text-xs font-semibold text-slate-500">
                                        €
                                      </span>
                                    </div>
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>
                        </div>

                        <div className="rounded-xl border border-slate-200 bg-white shadow-subtle">
                          <div className="border-b border-slate-200 bg-slate-50 px-5 py-4">
                            <h4 className="text-lg font-semibold text-slate-850">
                              Zuordnung Arbeitspakete und Mitarbeitende
                            </h4>
                            <p className="mt-1 text-sm text-slate-600">
                              Zeigt nur Arbeitspakete mit PM &gt; 0 aus der Projektplanung.
                            </p>
                          </div>
                          <div className="max-h-[320px] overflow-auto">
                            <div className="sticky top-0 z-10 border-b border-slate-200 bg-white/95 backdrop-blur">
                              <div className="grid grid-cols-[110px_minmax(240px,1.6fr)_minmax(140px,0.7fr)_minmax(140px,0.7fr)_130px_minmax(150px,0.9fr)] text-xs font-semibold uppercase text-slate-500">
                                <div className="px-4 py-3">WP-Nr.</div>
                                <div className="px-4 py-3">Arbeitspaket</div>
                                <div className="px-4 py-3">Start</div>
                                <div className="px-4 py-3">Ende</div>
                                <div className="px-4 py-3">MA-Nr.</div>
                                <div className="px-4 py-3 text-right">Kosten</div>
                              </div>
                            </div>
                            <div className="divide-y divide-slate-100">
                              {displayCompanyRows.map((row, index) => {
                                const isPlaceholder = row.isPlaceholder;
                                const entry =
                                  companyData[companyIndex]?.tabellenEintraege?.[row.id] || {};
                                const employeeNumber = parseInt(entry.mitarbeiterNummer, 10);
                                const employeeIndex = employeeNumber ? employeeNumber - 1 : null;
                                const pmDemand = isPlaceholder
                                  ? 0
                                  : row.pmByCompany?.[companyIndex] || 0;
                                const costPerPM =
                                  employeeIndex !== null
                                    ? companyCosts[employeeIndex]?.costPerPM || 0
                                    : 0;
                                const costValue =
                                  !isPlaceholder && employeeIndex !== null && pmDemand > 0
                                    ? formatCurrency(pmDemand * costPerPM)
                                    : "–";
                                return (
                                  <div
                                    key={`company-${companyIndex}-row-${row.id}`}
                                    className={`grid grid-cols-[110px_minmax(240px,1.6fr)_minmax(140px,0.7fr)_minmax(140px,0.7fr)_130px_minmax(150px,0.9fr)] items-center ${
                                      index % 2 === 0 ? "bg-white" : "bg-slate-50/60"
                                    }`}
                                  >
                                    <div className="px-4 py-2 text-sm font-semibold text-slate-700">
                                      {row.number}
                                    </div>
                                    <div className="px-4 py-2">
                                      <input
                                        type="text"
                                        readOnly
                                        value={row.title || ""}
                                        placeholder="Arbeitspaket-Titel"
                                        className="h-9 w-full rounded-md border border-slate-200 bg-slate-100 px-3 text-sm text-slate-700"
                                      />
                                    </div>
                                    <div className="px-4 py-2">
                                      <input
                                        type="text"
                                        value={isPlaceholder ? "" : entry.start || ""}
                                        onChange={(event) =>
                                          updateCompanyTableEntry(
                                            companyIndex,
                                            row.id,
                                            "start",
                                            event.target.value
                                          )
                                        }
                                        disabled={isPlaceholder}
                                        placeholder="MM.YYYY"
                                        className="h-9 w-full rounded-md border border-slate-300 px-3 text-sm text-slate-700 focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
                                      />
                                    </div>
                                    <div className="px-4 py-2">
                                      <input
                                        type="text"
                                        value={isPlaceholder ? "" : entry.ende || ""}
                                        onChange={(event) =>
                                          updateCompanyTableEntry(
                                            companyIndex,
                                            row.id,
                                            "ende",
                                            event.target.value
                                          )
                                        }
                                        disabled={isPlaceholder}
                                        placeholder="MM.YYYY"
                                        className="h-9 w-full rounded-md border border-slate-300 px-3 text-sm text-slate-700 focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
                                      />
                                    </div>
                                    <div className="px-4 py-2">
                                      <input
                                        type="number"
                                        min="1"
                                        max={companyEmployees.length || 1}
                                        step="1"
                                        value={isPlaceholder ? "" : entry.mitarbeiterNummer || ""}
                                        onChange={(event) =>
                                          updateCompanyTableEntry(
                                            companyIndex,
                                            row.id,
                                            "mitarbeiterNummer",
                                            event.target.value
                                          )
                                        }
                                        disabled={isPlaceholder}
                                        placeholder="MA-Nr."
                                        className="h-9 w-full rounded-md border border-slate-300 px-3 text-sm text-slate-700 focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
                                      />
                                    </div>
                                    <div className="px-4 py-2 text-right text-sm font-semibold text-slate-700">
                                      {costValue}
                                    </div>
                                  </div>
                                );
                              })}
                            </div>
                          </div>
                        </div>

                        <div className="rounded-xl border border-slate-200 bg-white shadow-subtle">
                          <div className="border-b border-slate-200 bg-slate-50 px-5 py-4">
                            <h4 className="text-lg font-semibold text-slate-850">
                              Mitarbeiter-Auslastung
                            </h4>
                            <p className="mt-1 text-sm text-slate-600">
                              Pro Kalenderjahr: PM und prozentuale Auslastung mit Gesamt-PM je MA.
                            </p>
                          </div>
                          <div className="overflow-auto">
                            <div
                              className="grid min-w-[760px] items-center border-b border-slate-200 bg-white text-xs font-semibold uppercase text-slate-500"
                              style={{
                                gridTemplateColumns: utilizationGridColumns,
                              }}
                            >
                              <div className="row-span-2 border-r border-slate-200 px-4 py-3">MA-Nr.</div>
                              {projectYears.map((year, yearIndex) => (
                                <div
                                  key={`util-head-year-${companyIndex}-${year}`}
                                  className={`col-span-2 px-4 py-2 text-center ${
                                    yearIndex < projectYears.length - 1
                                      ? "border-r border-slate-300"
                                      : ""
                                  }`}
                                >
                                  {year}
                                </div>
                              ))}
                              <div className="row-span-2 px-4 py-3 text-right">PM gesamt</div>
                              {projectYears.flatMap((year, yearIndex) => [
                                <div
                                  key={`util-head-${companyIndex}-${year}-pm`}
                                  className="border-t border-slate-200 px-4 py-2"
                                >
                                  PM
                                </div>,
                                <div
                                  key={`util-head-${companyIndex}-${year}-percent`}
                                  className={`border-t border-slate-200 px-4 py-2 ${
                                    yearIndex < projectYears.length - 1
                                      ? "border-r border-slate-300"
                                      : ""
                                  }`}
                                >
                                  Auslastung %
                                </div>,
                              ])}
                            </div>
                            <div className="divide-y divide-slate-100">
                              {companyEmployees.map((employee, employeeIndex) => (
                                <div
                                  key={`util-row-${companyIndex}-${employeeIndex}`}
                                  className={`grid items-center text-sm ${
                                    employeeIndex % 2 === 0 ? "bg-white" : "bg-slate-50/60"
                                  }`}
                                  style={{
                                    gridTemplateColumns: utilizationGridColumns,
                                  }}
                                >
                                  <div className="border-r border-slate-100 px-4 py-3 font-semibold text-slate-700">
                                    {employeeIndex + 1}
                                  </div>
                                  {projectYears.map((year, yearIndex) => {
                                    const usedPMRaw =
                                      usedPmByEmployee?.[employeeIndex]?.[year] ?? 0;
                                    const usedPM = Number.isFinite(usedPMRaw)
                                      ? usedPMRaw
                                      : 0;
                                    const projectPercent = getEffectiveProjectPercent(
                                      employee?.projectPercent
                                    );
                                    const annualMaxPm = YEAR_CAP_PM * (projectPercent / 100);
                                    const rawUtilization =
                                      annualMaxPm > 0 ? (usedPM / annualMaxPm) * 100 : 0;
                                    const utilization = clampNumber(rawUtilization, 0, 999);
                                    return (
                                      <React.Fragment
                                        key={`util-${companyIndex}-${employeeIndex}-${year}`}
                                      >
                                        <div className="px-4 py-3 text-sm font-semibold text-slate-700">
                                          {formatNumberDe(usedPM, 2)}
                                        </div>
                                        <div
                                          className={`px-4 py-3 text-sm text-slate-600 ${
                                            yearIndex < projectYears.length - 1
                                              ? "border-r border-slate-200"
                                              : ""
                                          }`}
                                        >
                                          {formatNumberDe(utilization, utilization % 1 === 0 ? 1 : 2)}%
                                        </div>
                                      </React.Fragment>
                                    );
                                  })}
                                  <div className="px-4 py-3 text-right text-sm font-semibold text-slate-700">
                                    {formatNumberDe(totalPmByEmployee?.[employeeIndex] || 0, 2)}
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>
                        </div>

                        <div className="rounded-xl border border-slate-200 bg-white shadow-subtle">
                          <div className="border-b border-slate-200 bg-slate-50 px-5 py-4">
                            <h4 className="text-lg font-semibold text-slate-850">
                              Förderparameter &amp; Ergebnisse
                            </h4>
                            <p className="mt-1 text-sm text-slate-600">
                              Eingaben sind editierbar, Ergebnisse werden live berechnet.
                            </p>
                          </div>
                          <div className="grid gap-6 p-5 lg:grid-cols-2">
                            <div className="space-y-4">
                              <div>
                                <label className="text-xs font-semibold uppercase text-slate-500">
                                  Förderquote (%)
                                </label>
                                <input
                                  type="number"
                                  value={
                                    companyData[companyIndex]?.foerderquotePercent ?? ""
                                  }
                                  onChange={(event) =>
                                    updateCompanyField(
                                      companyIndex,
                                      "foerderquotePercent",
                                      event.target.value
                                    )
                                  }
                                  className="mt-2 h-10 w-full rounded-md border border-slate-300 px-3 text-sm text-slate-700 focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
                                />
                              </div>
                              <div>
                                <label className="text-xs font-semibold uppercase text-slate-500">
                                  Zuschlagsfaktor (%)
                                </label>
                                <input
                                  type="number"
                                  value={
                                    companyData[companyIndex]?.zuschlagsfaktorPercent ?? ""
                                  }
                                  onChange={(event) =>
                                    updateCompanyField(
                                      companyIndex,
                                      "zuschlagsfaktorPercent",
                                      event.target.value
                                    )
                                  }
                                  className="mt-2 h-10 w-full rounded-md border border-slate-300 px-3 text-sm text-slate-700 focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
                                />
                              </div>
                              <div>
                                <label className="text-xs font-semibold uppercase text-slate-500">
                                  Maximale Fördersumme (€)
                                </label>
                                <input
                                  type="text"
                                  inputMode="decimal"
                                  value={getCurrencyInputDisplay(`maximalbetrag-${companyIndex}`, companyData[companyIndex]?.maximalbetrag ?? "")}
                                  onFocus={() => setFocusedCurrencyField(`maximalbetrag-${companyIndex}`)}
                                  onBlur={() => setFocusedCurrencyField(null)}
                                  onChange={(event) =>
                                    updateCompanyField(
                                      companyIndex,
                                      "maximalbetrag",
                                      parseNumber(event.target.value)
                                    )
                                  }
                                  className="mt-2 h-10 w-full rounded-md border border-slate-300 px-3 text-sm text-slate-700 focus:border-slate-500 focus:outline-none focus:ring-1 focus:ring-slate-500"
                                />
                              </div>
                            </div>
                            <div className="space-y-4">
                              <div className="flex items-center justify-between rounded-md border border-slate-200 px-3 py-2">
                                <span className="text-sm font-semibold text-slate-600">
                                  Personalkosten (€)
                                </span>
                                <span className="text-sm font-semibold text-slate-800">
                                  {formatCurrency(fundingResults.personalkosten)}
                                </span>
                              </div>
                              <div className="flex items-center justify-between rounded-md border border-slate-200 px-3 py-2">
                                <span className="text-sm font-semibold text-slate-600">
                                  Projektsumme (€)
                                </span>
                                <span className="text-sm font-semibold text-slate-800">
                                  {formatCurrency(fundingResults.projektsumme)}
                                </span>
                              </div>
                              <div className="flex items-center justify-between rounded-md border border-slate-300 bg-slate-50 px-3 py-2 shadow-sm">
                                <span className="text-sm font-bold text-slate-700">
                                  Fördersumme (€)
                                </span>
                                <span className="text-sm font-bold text-slate-900">
                                  {formatCurrency(fundingResults.foerdersumme)}
                                </span>
                              </div>
                              <div className="flex items-center justify-between rounded-md border border-slate-300 bg-slate-50 px-3 py-2 shadow-sm">
                                <span className="text-sm font-bold text-slate-700">
                                  Verschenkt zum Maximalbetrag (€)
                                </span>
                                <span className="text-sm font-bold text-slate-900">
                                  {formatCurrency(fundingResults.verschenkt)}
                                </span>
                              </div>
                              <div className="flex items-center justify-between rounded-md border border-slate-300 bg-slate-50 px-3 py-2 shadow-sm">
                                <span className="text-sm font-bold text-slate-700">
                                  Realer Zuschlagsfaktor (%)
                                </span>
                                <span className="text-sm font-bold text-slate-900">
                                  {formatNumberDe(fundingResults.realerZuschlagsfaktor)}%
                                </span>
                              </div>
                              {projectYears.map((year) => (
                                <div key={`annual-funding-${companyIndex}-${year}`} className="flex items-center justify-between rounded-md border border-slate-200 px-3 py-2">
                                  <span className="text-sm font-semibold text-slate-600">
                                    Fördersumme ({year})
                                  </span>
                                  <span className="text-sm font-semibold text-slate-800">
                                    {formatCurrency(fundingResults.annualFunding?.[year] || 0)}
                                  </span>
                                </div>
                              ))}
                            </div>
                          </div>
                        </div>
                      </div>
                    </section>
                  );
                })}
              </div>
            </main>

            {fullscreenCompanyData ? (
              <div className="fixed inset-0 z-[65] bg-slate-950/55 p-3 md:p-6">
                <div className="flex h-full w-full flex-col overflow-hidden rounded-xl border border-slate-200 bg-white shadow-2xl">
                  <div className="flex items-center justify-between px-5 py-4 text-white" style={{ backgroundColor: fullscreenCompanyData.color }}>
                    <div>
                      <p className="text-xs font-semibold uppercase tracking-[0.16em] text-white/80">Projektplanung</p>
                      <h3 className="text-xl font-semibold">{fullscreenCompanyData.companyName}</h3>
                    </div>
                    <button
                      type="button"
                      onClick={() => setFullscreenCompanyIndex(null)}
                      className="fullscreen-overlay-close rounded-md border border-white/60 px-3 py-1 text-sm font-semibold text-white hover:bg-white/15"
                    >
                      Schließen
                    </button>
                  </div>
                  <div className="flex-1 space-y-6 overflow-auto p-5">
                    <section className="rounded-lg border border-slate-200">
                      <div className="border-b border-slate-200 bg-slate-50 px-4 py-3 text-sm font-semibold text-slate-800">Arbeitspaketübersicht</div>
                      <div className="overflow-auto">
                        <table className="min-w-full text-sm">
                          <thead className="bg-slate-50 text-left text-xs font-semibold uppercase text-slate-500">
                            <tr>
                              <th className="px-3 py-2">Arbeitspaketnummer</th>
                              <th className="px-3 py-2">Bezeichnung des Arbeitspakets</th>
                              <th className="px-3 py-2">Startdatum</th>
                              <th className="px-3 py-2">Enddatum</th>
                              <th className="px-3 py-2">Mitarbeiternummer</th>
                              <th className="px-3 py-2 text-right">Personenmonate</th>
                            </tr>
                          </thead>
                          <tbody className="divide-y divide-slate-100">
                            {fullscreenCompanyData.workPackageRows.map((row) => (
                              <tr key={`fs-ap-${row.id}`}>
                                <td className="px-3 py-2 font-semibold text-slate-700">{row.number}</td>
                                <td className="px-3 py-2 text-slate-700">{row.title}</td>
                                <td className="px-3 py-2 text-slate-700">{row.start}</td>
                                <td className="px-3 py-2 text-slate-700">{row.end}</td>
                                <td className="px-3 py-2 text-slate-700">{row.employeeNumber}</td>
                                <td className="px-3 py-2 text-right font-semibold text-slate-800">{formatNumberDe(row.pm, 2)}</td>
                              </tr>
                            ))}
                            {!fullscreenCompanyData.workPackageRows.length ? (
                              <tr>
                                <td colSpan={6} className="px-3 py-3 text-center text-slate-500">Keine Arbeitspakete mit PM &gt; 0 vorhanden.</td>
                              </tr>
                            ) : null}
                          </tbody>
                        </table>
                      </div>
                    </section>

                    <section className="rounded-lg border border-slate-200">
                      <div className="border-b border-slate-200 bg-slate-50 px-4 py-3 text-sm font-semibold text-slate-800">Mitarbeiterauswertung (pro Jahr)</div>
                      <div className="overflow-auto">
                        <table className="min-w-full text-sm">
                          <thead className="bg-slate-50 text-left text-xs font-semibold uppercase text-slate-500">
                            <tr>
                              <th className="px-3 py-2">Mitarbeitenden-Nr.</th>
                              <th className="px-3 py-2">Name</th>
                              {fullscreenCompanyData.projectYears.flatMap((year) => [
                                <th key={`fs-head-${year}-pm`} className="px-3 py-2 text-right">{year} PM</th>,
                                <th key={`fs-head-${year}-cost`} className="px-3 py-2 text-right">{year} Kosten</th>,
                              ])}
                            </tr>
                          </thead>
                          <tbody className="divide-y divide-slate-100">
                            {fullscreenCompanyData.employees.map((employee, index) => (
                              <tr key={`fs-emp-${index}`}>
                                <td className="px-3 py-2 font-semibold text-slate-700">{employee.number}</td>
                                <td className="px-3 py-2 text-slate-700">{employee.name}</td>
                                {fullscreenCompanyData.projectYears.flatMap((year) => [
                                  <td key={`fs-emp-${index}-${year}-pm`} className="px-3 py-2 text-right text-slate-700">{formatNumberDe(employee.years?.[year]?.pm || 0, 2)}</td>,
                                  <td key={`fs-emp-${index}-${year}-cost`} className="px-3 py-2 text-right font-semibold text-slate-800">{formatCurrency(employee.years?.[year]?.cost || 0)}</td>,
                                ])}
                              </tr>
                            ))}
                            {!fullscreenCompanyData.employees.length ? (
                              <tr>
                                <td colSpan={2 + fullscreenCompanyData.projectYears.length * 2} className="px-3 py-3 text-center text-slate-500">Keine Mitarbeitenden vorhanden.</td>
                              </tr>
                            ) : null}
                          </tbody>
                        </table>
                      </div>
                    </section>

                    <section className="rounded-lg border border-slate-200">
                      <div className="border-b border-slate-200 bg-slate-50 px-4 py-3 text-sm font-semibold text-slate-800">Förderübersicht (pro Jahr)</div>
                      <div className="overflow-auto">
                        <table className="min-w-full text-sm">
                          <thead className="bg-slate-50 text-left text-xs font-semibold uppercase text-slate-500">
                            <tr>
                              <th className="px-3 py-2">Jahr</th>
                              <th className="px-3 py-2 text-right">Personalkosten</th>
                              <th className="px-3 py-2 text-right">Projektsumme</th>
                              <th className="px-3 py-2 text-right">Beantragter Zuschuss</th>
                            </tr>
                          </thead>
                          <tbody className="divide-y divide-slate-100">
                            {fullscreenCompanyData.yearlyFundingRows.map((row) => (
                              <tr key={`fs-funding-${row.year}`}>
                                <td className="px-3 py-2 font-semibold text-slate-700">{row.year}</td>
                                <td className="px-3 py-2 text-right text-slate-700">{formatCurrency(row.personalkosten)}</td>
                                <td className="px-3 py-2 text-right text-slate-700">{formatCurrency(row.projektsumme)}</td>
                                <td className="px-3 py-2 text-right font-semibold text-slate-800">{formatCurrency(row.foerderung)}</td>
                              </tr>
                            ))}
                            <tr className="bg-slate-50">
                              <td className="px-3 py-2 font-semibold text-slate-800">Summe</td>
                              <td className="px-3 py-2 text-right font-semibold text-slate-800">{formatCurrency(fullscreenCompanyData.totals.personalkosten)}</td>
                              <td className="px-3 py-2 text-right font-semibold text-slate-800">{formatCurrency(fullscreenCompanyData.totals.projektsumme)}</td>
                              <td className="px-3 py-2 text-right font-semibold text-slate-900">{formatCurrency(fullscreenCompanyData.totals.foerderung)}</td>
                            </tr>
                          </tbody>
                        </table>
                      </div>
                    </section>
                  </div>
                </div>
              </div>
            ) : null}

            {zimPdfModalState.open ? (
              <div className="fixed inset-0 z-[70] flex items-center justify-center bg-slate-950/50 px-4">
                <div className="max-h-[90vh] w-full max-w-5xl overflow-auto rounded-xl border border-slate-200 bg-white p-5 shadow-2xl">
                  <div className="flex items-start justify-between gap-4">
                    <div>
                      <h3 className="text-lg font-semibold text-slate-900">Projektplanung in ZIM-Fördermittelantrag übertragen</h3>
                      <p className="mt-1 text-sm text-slate-600">Bitte Mantelbogen-PDF hochladen (Formular-PDF)</p>
                    </div>
                    <button type="button" onClick={closeZimModal} className="rounded-md border border-slate-300 px-3 py-1 text-sm">Schließen</button>
                  </div>
                  <div className="mt-4 rounded-md border border-slate-200 bg-slate-50 p-4">
                    <label className="text-sm font-semibold text-slate-800">1) PDF hochladen</label>
                    <input
                      type="file"
                      accept="application/pdf"
                      onChange={(event) => setZimPdfModalState((prev) => ({ ...prev, uploadedFile: event.target.files?.[0] || null }))}
                      className="mt-2 block w-full text-sm"
                    />
                    <button
                      type="button"
                      onClick={analyzeZimPdf}
                      disabled={!zimPdfModalState.uploadedFile}
                      className="mt-3 rounded-md border border-slate-300 px-3 py-2 text-sm font-semibold text-slate-700 disabled:cursor-not-allowed disabled:opacity-60"
                    >
                      PDF analysieren
                    </button>
                  </div>
                  {zimPdfModalState.analysisError ? <div className="mt-3 rounded-md border border-rose-200 bg-rose-50 px-3 py-2 text-sm text-rose-700">{zimPdfModalState.analysisError}</div> : null}
                  {zimPdfModalState.analysisMessage ? <div className="mt-3 rounded-md border border-emerald-200 bg-emerald-50 px-3 py-2 text-sm text-emerald-700">{zimPdfModalState.analysisMessage}</div> : null}
                  {zimPdfModalState.noFormFields ? (
                    <div className="mt-3 rounded-md border border-amber-300 bg-amber-50 px-3 py-2 text-sm text-amber-800">Diese PDF scheint keine ausfüllbaren Formularfelder zu enthalten.</div>
                  ) : null}
                  <div className="mt-4 grid gap-4 lg:grid-cols-2">
                    <div className="rounded-md border border-slate-200 p-3">
                      <h4 className="text-sm font-semibold text-slate-800">2) Akronym-Check</h4>
                      <div className="mt-2 text-sm text-slate-700">Acronym in PDF: <strong>{zimPdfModalState.acronymInPdf || "–"}</strong></div>
                      <div className="text-sm text-slate-700">Projektname (Acronym) in Software: <strong>{currentProjectName || "–"}</strong></div>
                      {zimPdfModalState.acronymStatus === "missing" ? <div className="mt-2 text-sm text-amber-700">Akronym konnte in der PDF nicht automatisch gefunden werden.</div> : null}
                      {zimPdfModalState.acronymStatus === "mismatch" ? (
                        <div className="mt-2 rounded-md border border-amber-300 bg-amber-50 px-3 py-2 text-sm text-amber-800">
                          Warnung: Akronym in der PDF stimmt nicht mit dem Projektnamen überein.
                          <div className="mt-2 flex gap-2">
                            <button type="button" onClick={() => setZimPdfModalState((prev) => ({ ...prev, warningAccepted: true }))} className="rounded-md border border-amber-400 bg-white px-2 py-1 text-xs font-semibold">Trotzdem fortfahren</button>
                            <button type="button" onClick={closeZimModal} className="rounded-md border border-slate-300 bg-white px-2 py-1 text-xs font-semibold">Abbrechen</button>
                          </div>
                        </div>
                      ) : null}
                    </div>
                    <div className="rounded-md border border-slate-200 p-3">
                      <h4 className="text-sm font-semibold text-slate-800">3) Mapping-Vorschau</h4>
                      <div className="mt-2 text-xs text-slate-500">Befüllbare Felder: {zimPdfModalState.mappings.length}</div>
                      <div className="max-h-40 overflow-auto text-xs">
                        {zimPdfModalState.mappings.map((entry) => (
                          <div key={`map-${entry.path}`} className="mt-1 rounded bg-emerald-50 px-2 py-1 text-emerald-800">{entry.path} ← {`${entry.value}` || ""}</div>
                        ))}
                      </div>
                      <div className="mt-3 text-xs text-slate-500">Nicht automatisch befüllbar: {zimPdfModalState.unmappedFields.length}</div>
                      <div className="max-h-28 overflow-auto text-xs">
                        {zimPdfModalState.unmappedFields.map((fieldName) => (
                          <div key={`unmap-${fieldName}`} className="mt-1 rounded bg-slate-100 px-2 py-1 text-slate-600">{fieldName}</div>
                        ))}
                      </div>
                      {!zimPdfModalState.mappings.some((entry) => /arbeitspaket|\bap\b/i.test(entry.path || "")) ? (
                        <div className="mt-2 text-xs text-amber-700">AP-Tabelle nicht als Formularfelder vorhanden.</div>
                      ) : null}
                    </div>
                  </div>
                  <div className="mt-4 rounded-md border border-slate-200 p-3">
                    <h4 className="text-sm font-semibold text-slate-800">Debug/Entwickleransicht: Erkannte PDF-Feldnamen</h4>
                    <div className="mt-2 max-h-40 overflow-auto text-xs text-slate-700">
                      {zimPdfModalState.fieldNames.map((fieldName) => (
                        <div key={`field-${fieldName}`} className="border-b border-slate-100 py-1">{fieldName}</div>
                      ))}
                    </div>
                  </div>
                  <div className="mt-5 flex flex-wrap items-center justify-end gap-2">
                    <button
                      type="button"
                      onClick={exportZimPdf}
                      disabled={!zimPdfModalState.uploadedFile || !zimPdfModalState.fieldNames.length || (zimPdfModalState.acronymStatus === "mismatch" && !zimPdfModalState.warningAccepted)}
                      className="rounded-md bg-slate-900 px-3 py-2 text-sm font-semibold text-white disabled:cursor-not-allowed disabled:bg-slate-300"
                    >
                      PDF ausfüllen & herunterladen
                    </button>
                    {zimPdfModalState.downloadUrl ? (
                      <a href={zimPdfModalState.downloadUrl} download={zimPdfModalState.downloadName} className="rounded-md border border-emerald-400 bg-emerald-50 px-3 py-2 text-sm font-semibold text-emerald-800">
                        Download: {zimPdfModalState.downloadName}
                      </a>
                    ) : null}
                  </div>
                </div>
              </div>
            ) : null}

            {newProjectModalOpen ? (
              <div className="fixed inset-0 z-[60] flex items-center justify-center bg-slate-950/40 px-4">
                <div className="w-full max-w-md rounded-xl border border-slate-200 bg-white p-5 shadow-2xl">
                  <h3 className="text-lg font-semibold text-slate-900">Neues Projekt anlegen</h3>
                  <p className="mt-1 text-sm text-slate-600">
                    Bitte geben Sie einen eindeutigen Projektnamen ein.
                  </p>
                  <input
                    type="text"
                    value={newProjectName}
                    onChange={(event) => {
                      setNewProjectName(event.target.value);
                      setProjectError("");
                    }}
                    placeholder="Projektname"
                    className="ca-focus mt-4 h-10 w-full rounded-md border border-slate-300 px-3 text-sm"
                  />
                  {projectError ? (
                    <div className="mt-2 text-sm font-medium text-rose-600">{projectError}</div>
                  ) : null}
                  <div className="mt-5 flex justify-end gap-2">
                    <button
                      type="button"
                      onClick={() => {
                        setNewProjectModalOpen(false);
                        setNewProjectName("");
                        setProjectError("");
                      }}
                      className="rounded-md border border-slate-300 px-3 py-2 text-sm font-semibold text-slate-700"
                    >
                      Abbrechen
                    </button>
                    <button
                      type="button"
                      onClick={createNewProject}
                      className="ca-primary-btn rounded-md px-3 py-2 text-sm font-semibold"
                    >
                      Projekt erstellen
                    </button>
                  </div>
                </div>
              </div>
            ) : null}

            {loadProjectModalOpen ? (
              <div className="fixed inset-0 z-[60] flex items-center justify-center bg-slate-950/40 px-4">
                <div className="w-full max-w-2xl rounded-xl border border-slate-200 bg-white p-5 shadow-2xl">
                  <h3 className="text-lg font-semibold text-slate-900">Projekt laden</h3>
                  <input
                    type="text"
                    value={projectSearchTerm}
                    onChange={(event) => setProjectSearchTerm(event.target.value)}
                    placeholder="Projektname suchen"
                    className="ca-focus mt-4 h-10 w-full rounded-md border border-slate-300 px-3 text-sm"
                  />
                  <div className="mt-4 max-h-[360px] overflow-auto rounded-md border border-slate-200">
                    {filteredProjectRecords.length ? (
                      <table className="min-w-full text-sm">
                        <thead className="bg-slate-50 text-left text-slate-600">
                          <tr>
                            <th className="px-3 py-2">Projektname</th>
                            <th className="px-3 py-2">Zuletzt bearbeitet</th>
                            <th className="px-3 py-2">Status</th>
                          </tr>
                        </thead>
                        <tbody>
                          {filteredProjectRecords.map((project) => (
                            <tr
                              key={project.name}
                              className={`border-t border-slate-100 ${project.loadable === false ? "bg-rose-50" : "cursor-pointer hover:bg-slate-50"}`}
                              onClick={() => project.loadable === false ? null : handleProjectLoad(project.name)}
                            >
                              <td className="px-3 py-2 font-medium text-slate-800">{project.name}</td>
                              <td className="px-3 py-2 text-slate-600">{formatDateTimeDe(project.lastModified)}</td>
                              <td className="px-3 py-2 text-slate-600">{project.loadable === false ? "Nicht ladbar" : "Ladbar"}</td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    ) : (
                      <div className="px-3 py-4 text-sm text-slate-500">Keine Projekte gefunden</div>
                    )}
                  </div>
                  <div className="mt-5 flex justify-between gap-2">
                    <button
                      type="button"
                      onClick={restoreCryoVisionProject}
                      className="rounded-md border border-[var(--ca-green-border)] px-3 py-2 text-sm font-semibold text-slate-700"
                    >
                      CryoVision wiederherstellen
                    </button>
                    <button
                      type="button"
                      onClick={() => {
                        setLoadProjectModalOpen(false);
                        setProjectSearchTerm("");
                      }}
                      className="rounded-md border border-slate-300 px-3 py-2 text-sm font-semibold text-slate-700"
                    >
                      Schließen
                    </button>
                  </div>
                </div>
              </div>
            ) : null}
          </div>
        );
      };

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
